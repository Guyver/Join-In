<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>OpenNI 1.5.4: UserTracker.net - sample program (C#)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="main.html">OpenNI Overview</a>&nbsp;&raquo;&nbsp;<a class="el" href="smpls__n__guides.html">Samples and Guides</a>&nbsp;&raquo;&nbsp;<a class="el" href="smpls.html">Sample Programs for the OpenNI API</a>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="smpl_user_tracker_net">UserTracker.net - sample program (C#) </a></h1><p><b>Source file:</b> Click the following link to view the source code file:</p>
<ul>
<li>UserTracker.net\MainWindow.cs</li>
</ul>
<p>The User Tracker sample program demonstrates the OpenNI code for tracking the movement of a user through its skeleton capability. This sample program is contained in the UserTracker.net file.</p>
<p>This major section describes the OpenNI program code of the User Tracker sample program written in the C# language for .NET.</p>
<p>The documentation describes the program code from the top of the program file(s) to bottom, unless otherwise indicated.</p>
<p>All the following sections document the OpenNI code in the <code>UserTracker.net </code> file.</p>
<h2><a class="anchor" id="utcs_main">
MainWindow() method</a></h2>
<p>The <code>MainWindow()</code> routine is located in the <code>MainWindow.cs</code> file. It is shown in the following code block. This routine performs data declarations and initializations. At the end of this routine, it calls the <code>readerThread.Start()</code> method, which manages updating the OpenNI generated data for user access.</p>
<h2><a class="anchor" id="utcs_refto_glb_dcl_blk">
Global Declaration Block</a></h2>
<p>The global declaration block is located at the end of the program file. However it is presented and described here for the convenience of the reader.</p>
<p>The following declarations define the OpenNI objects required for building the OpenNI production graph. The production graph is the main object model in OpenNI. </p>
<div class="fragment"><pre class="fragment">            <span class="keyword">private</span> OutArg&lt;ScriptNode&gt; scriptNode;
            <span class="keyword">private</span> Context context;
            <span class="keyword">private</span> DepthGenerator depthGen;
            <span class="keyword">private</span> UserGenerator userGen;
            <span class="keyword">private</span> SkeletonCapability skeletonCap;
            <span class="keyword">private</span> PoseDetectionCapability poseDetectionCap;
</pre></div><p>Each of these declarations is described separately in the following paragraphs.</p>
<p>The <a class="el" href="classxn_1_1_script_node.html">xn::ScriptNode</a> object loads an XML script from a file or string, and then runs the XML script to build a production graph. The ScriptNode object must be kept alive as long as the other nodes are needed. </p>
<div class="fragment"><pre class="fragment">            <span class="keyword">private</span> OutArg&lt;ScriptNode&gt; scriptNode;
</pre></div><p>The <em>production graph</em> is a network of software objects - called production nodes - that can identify blobs as hands or human users. In this sample program the production graph identifies blobs as human users, and tracks them as they move.</p>
<p>A <a class="el" href="classxn_1_1_context.html">xn::Context</a> object is a workspace in which the application builds an OpenNI production graph. </p>
<div class="fragment"><pre class="fragment">            <span class="keyword">private</span> Context context;
</pre></div><p>a <a class="el" href="classxn_1_1_depth_generator.html">xn::DepthGenerator</a> node generates a depth map. Each map pixel value represents a distance from the sensor. </p>
<div class="fragment"><pre class="fragment">            DepthGenerator depthGen;
</pre></div><p>A <a class="el" href="classxn_1_1_user_generator.html">xn::UserGenerator</a> node generates data describing users that it recognizes in the scene, identifying each user individually and thus allowing actions to be done on specific users. The single UserGenerator node gets ata for all users appearing in the scene. </p>
<div class="fragment"><pre class="fragment">            <span class="keyword">private</span> UserGenerator userGen;
</pre></div><p>The <a class="el" href="classxn_1_1_skeleton_capability.html">xn::SkeletonCapability</a> lets the node generate a skeleton representation for each human user generated by the node. Each UserGenerator node can have exactly one skeleton representation. The skeleton data includes the location of the skeletal joints, the ability to track skeleton positions and the user calibration capabilities. To help track a user's skeleton, the <a class="el" href="classxn_1_1_skeleton_capability.html">xn::SkeletonCapability</a> can execute a calibration process to measure and record the lengths of the human user's limbs. </p>
<div class="fragment"><pre class="fragment">            <span class="keyword">private</span> SkeletonCapability skeletonCap;
</pre></div><p>The PoseDetectionCapability object lets a <a class="el" href="classxn_1_1_user_generator.html">UserGenerator</a> node recognize when the user is posed in a specific position. </p>
<div class="fragment"><pre class="fragment">            <span class="keyword">private</span> PoseDetectionCapability poseDetectionCap;
</pre></div><h2><a class="anchor" id="utcs_func_main">
Main Program - MainWindow()</a></h2>
<h3><a class="anchor" id="svcs_scrpt_sets_up_pg">
Use Script to Set up a Context and Production Graph</a></h3>
<p>The following code block uses a script to set up a context and a production graph. The <a class="el" href="classxn_1_1_context.html#aa0f2dff24c434ed56b44332456ea9502">createFromXmlFile()</a> method, which is a shorthand combination of two other initialization methods, initializes the context object and then creates a production graph from an XML file. The XML script file describes all the nodes you want to create. For each node description in the XML file, this method creates a node in the production graph. See <a href="bmrk_nodedescr"><b>OpenNI Nodes Declarations</b></a> for explanations of the production graph and generator nodes. </p>
<div class="fragment"><pre class="fragment">                this.context = Context.CreateFromXmlFile(SAMPLE_XML_FILE, out scriptNode);
</pre></div><h3><a class="anchor" id="svcs_get_nodes_from_prodgrph">
Gets Nodes from Production Graph</a></h3>
<p>In the following statement, the <a class="el" href="classxn_1_1_context.html#a48450b0fde8c947c8ba7683a4f882308">FindExistingNode()</a> call gets a reference to production nodes in the production graph. In this example, the application passes the NodeType.Depth parameter to get a reference to a <a class="el" href="classxn_1_1_depth_generator.html">DepthGenerator node</a> so that it can work with it. </p>
<div class="fragment"><pre class="fragment">                this.depth = context.FindExistingNode( ) as DepthGenerator;
</pre></div><p>The following code block demonstrates verifying that the script file defined a <a class="el" href="classxn_1_1_depth_generator.html">xn::DepthGenerator</a> node. </p>
<div class="fragment"><pre class="fragment">                <span class="keywordflow">if</span> (this.depth == null)
                {
                    <span class="keywordflow">throw</span> <span class="keyword">new</span> Exception(<span class="stringliteral">&quot;Viewer must have a depth node!&quot;</span>);
                }           
</pre></div><h3><a class="anchor" id="utcs_create_ug_node">
Creates a UserGenerator Node</a></h3>
<p>The following program code creates a <a class="el" href="classxn_1_1_user_generator.html">UserGenerator</a> node and then gets two capabilities of the node: a <a class="el" href="classxn_1_1_skeleton_capability.html">SkeletonCapability</a> object and a <a class="el" href="classxn_1_1_pose_detection_capability.html">PoseDetectionCapability</a> object. The code then assigns references to the two capabilities for easy access to them. </p>
<div class="fragment"><pre class="fragment">                this.userGenerator = <span class="keyword">new</span> UserGenerator(this.context);
                this.skeletonCapbility = this.userGenerator.SkeletonCapability;
                this.poseDetectionCapability = this.userGenerator.PoseDetectionCapability;
                this.calibPose = this.skeletonCapbility.CalibrationPose;
</pre></div><p>Each of these declarations is described separately in the following paragraphs.</p>
<p>The following statement creates and returns a reference to a <a class="el" href="classxn_1_1_user_generator.html">UserGenerator</a> node. The <code>new() </code> constructor can return a reference to an existing UserGenerator node if one already exists in the production graph created from the XML. If no UserGenerator node already exists, the constructor creates a new UserGenerator node and returns a reference to the new node. </p>
<div class="fragment"><pre class="fragment">                this.userGenerator = <span class="keyword">new</span> UserGenerator(this.context);
</pre></div><p>The following two statements get a <a class="el" href="classxn_1_1_skeleton_capability.html">xn::SkeletonCapability</a> object for accessing Skeleton functionality and a PoseDetectionCapability for accessing Pose Detection functionality. </p>
<div class="fragment"><pre class="fragment">                this.skeletonCapbility = this.userGenerator.SkeletonCapability;
                this.poseDetectionCapability = this.userGenerator.PoseDetectionCapability;
</pre></div><p>The following statement gets the name of the pose that is required for calibration. The pose and its name reside in the plug-in module that provides the <a class="el" href="classxn_1_1_skeleton_capability.html">xn::SkeletonCapability</a>. The pose's name and details are defined by the developer of the module. The pose name is only needed when online calibration is turned off. This is seen in the callbacks described later. </p>
<div class="fragment"><pre class="fragment">                this.calibPose = this.skeletonCapability.CalibrationPose;               
</pre></div><h3><a class="anchor" id="utcs_init_event_hndlrs">
Initializes Event Handlers</a></h3>
<p>The following code block registers two event handlers for the UserGenerator node, and event handlers for its two capabilities: the <a class="el" href="classxn_1_1_skeleton_capability.html">SkeletonCapability</a> object and a <a class="el" href="classxn_1_1_pose_detection_capability.html">PoseDetectionCapability</a> object. </p>
<div class="fragment"><pre class="fragment">                this.userGenerator.NewUser += userGenerator_NewUser;
                this.userGenerator.LostUser += userGenerator_LostUser;
                this.poseDetectionCapability.PoseDetected += poseDetectionCapability_PoseDetected;
                this.skeletonCapbility.CalibrationComplete += skeletonCapbility_CalibrationComplete;
</pre></div><p>See <a class="el" href="smpl__user__tracker__net.html#utcs_event_handlers">Declarations of Event Handlers</a> for the descriptions of these events and their usages.</p>
<h3><a class="anchor" id="utcs_set_ske_prfl">
Sets the Skeleton Profile</a></h3>
<p>In the following statement, the <a class="el" href="classxn_1_1_skeleton_capability.html#ab07ee49ccdb7278945af4144bb115c15">setSkeletonProfile()</a> sets the skeleton profile. The skeleton profile specifies which joints are to be active, and which to be inactive. The <a class="el" href="classxn_1_1_user_generator.html">xn::UserGenerator</a> node generates output data for the active joints only. This profile applies to all skeletons that the <a class="el" href="classxn_1_1_user_generator.html">xn::UserGenerator</a> node generates. In this case, the method sets all joints to be active. </p>
<div class="fragment"><pre class="fragment">                this.skeletonCapbility.SetSkeletonProfile(SkeletonProfile.All);
</pre></div><h3><a class="anchor" id="utcs_init_joints_array">
Initializes the 'joints' Array</a></h3>
<p>The following statement initializes the 'joints' array. The 'joints' array maintains for each user a mapping of the current position of each joint, as follows:</p>
<div class="fragment"><pre class="fragment">
				(user ID-&gt;(SkeletonJoint-&gt;SkeletonJointPosition))*)		
			</pre></div><p>Each entry maps a particular <code><a class="el" href="_xn_types_8h.html#a7713dc7b4e1415ffe6c835c5979d65f4">xn::XnSkeletonJoint</a></code> "skeleton joint" (an ID identifying a particular joint in the skeleton) to its <code>keletonJointPosition</code> "3D position". </p>
<div class="fragment"><pre class="fragment">                this.joints = <span class="keyword">new</span> Dictionary&lt;int,Dictionary&lt;SkeletonJoint,SkeletonJointPosition&gt;&gt;();
</pre></div><h3><a class="anchor" id="utcs_start_node_generating">
Starts the Node Generating</a></h3>
<p>The following statement ensures that all created <a class="el" href="glossary.html#dict_gen_node">generator nodes</a> are in Generating state. Each node can be in Generating state or Non-Generating state. When a node is in Generating state it generates data. </p>
<div class="fragment"><pre class="fragment">                context.startGeneratingAll();
</pre></div><h3><a class="anchor" id="utcs_setup_hist_array">
Sets up the Histogram Array</a></h3>
<p>The following statement defines the histogram array, and dimensions it using the sensor device's maximum depth. (This code is not OpenNI specific.) This array is a key part of this sample program. the <a class="el" href="classxn_1_1_depth_generator.html#a961df8ceab308f1d1b89c4fd99b4584c">DeviceMaxDepth()</a> method gets the maximum depth value that the DepthGenerator node can generate. </p>
<div class="fragment"><pre class="fragment">                this.histogram = <span class="keyword">new</span> <span class="keywordtype">int</span>[this.depth.DeviceMaxDepth];
</pre></div><h3><a class="anchor" id="utcs_setup_map_out_mode">
Sets up the MapOutputMode</a></h3>
<p>The following statement gets the Map Output mode of the <a class="el" href="classxn_1_1_depth_generator.html">DepthGenerator</a> node. The map output mode is the combination of the node's scene resolution and frame rate that was set to generate the latest frame. </p>
<div class="fragment"><pre class="fragment">                MapOutputMode mapMode = this.depth.MapOutputMode;
</pre></div><p>The following statement accesses the Map Output mode to get the DepthGenerator's map dimensions and pixel color format. <a class="el" href="classxn_1_1_map.html#addae31672b376dc4a79d8856b831ab1b">XRes</a> and <a class="el" href="classxn_1_1_map.html#a12df2e51951f42f4265e27e14d8d412b">YRes</a> get the frame X an Y resolutions of the most recently generated data. X and is the number of columns and rows, respectively, in the frame after any required cropping has been applied. See <a class="el" href="conc__map__wrapper__classes.html">Map Wrapper Classes</a> for more information.<br/>
</p>
<h3><a class="anchor" id="utcs_setup_bitmap">
Sets up the Bitmap Class and Start Run</a></h3>
<p><code>bitmap</code> is not itself OpenNI object. In brief, the <code>bitmap</code> object is an instance of the .NET Bitmap class for work with images defined by pixel data. It is defined with dimensions given by the values of the OpenNI <a class="el" href="classxn_1_1_map.html#addae31672b376dc4a79d8856b831ab1b">XRes</a> and <a class="el" href="classxn_1_1_map.html#a12df2e51951f42f4265e27e14d8d412b">YRes</a>, i.e, the x-y dimensions of the DepthGenerator node. </p>
<div class="fragment"><pre class="fragment">                this.bitmap = <span class="keyword">new</span> Bitmap((<span class="keywordtype">int</span>)mapMode.XRes, (<span class="keywordtype">int</span>)mapMode.YRes)
</pre></div><p>Finally, the following code block sets up the reader thread and starts it running. </p>
<div class="fragment"><pre class="fragment">                this.shouldRun = <span class="keyword">true</span>;
                this.readerThread = <span class="keyword">new</span> Thread(ReaderThread);
                this.readerThread.Start();          
</pre></div><h2><a class="anchor" id="utcs_event_handlers">
Declarations of Event Handlers</a></h2>
<p>This section describes the event handlers this sample program requires, describing the nature of the events themselves and what is done inside the handlers.</p>
<p>A typical order of invocation of the events used in this sample program would be: 1. 'New User' event 2. 'Pose Detected' event (optional) 3. 'Calibration Complete' event 4. 'Lost User' event</p>
<p>The events are described below in order of their declaration in the source code.</p>
<h3><a class="anchor" id="utcs_calibcmplt_ev_hndlr">
'Calibration Complete' event handler</a></h3>
<p>The <b>'Calibration Complete' event</b> signals that a specific user's skeleton has now completed the calibration process, and provides a result status. The user is identified by the ID given by the <code>e.ID</code> parameter.</p>
<p>The <b>'Calibration Complete' event handler</b> is as below. It's processing is as follows. The handler tests whether the calibration process was completed successfully. If yes, that means that a user has been detected and calibrated, and enough information has been obtained to create a skeleton to represent the user.</p>
<p>The handler then advances the processing to the next stage, i.e., to call <a class="el" href="classxn_1_1_hands_generator.html#ac60c64231895f76465d795b3ca603778">xn::HandsGenerator::StartTracking()</a> to start tracking the skeleton, which represents a human user body, within a real-life (3D) scene for analysis, interpretation, and use by the application. (Description continued after the code.) </p>
<div class="fragment"><pre class="fragment">                <span class="keywordtype">void</span> skeletonCapbility_CalibrationComplete(<span class="keywordtype">object</span> sender, CalibrationProgressEventArgs e)
                {
                    <span class="keywordflow">if</span> (e.Status == CalibrationStatus.OK)
                    {
                        this.skeletonCapbility.xn::(e.ID);
                        this.joints.Add(e.ID, <span class="keyword">new</span> Dictionary&lt;SkeletonJoint, SkeletonJointPosition&gt;());
                    }
                    
                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (e.Status != CalibrationStatus.ManualAbort)
                {
                    <span class="keywordflow">if</span> (this.skeletonCapbility.DoesNeedPoseForCalibration)
                 {
                     this.poseDetectionCapability.StartPoseDetection(calibPose, e.ID);
                 }
                    <span class="keywordflow">else</span>    
                    {
                     this.skeletonCapbility.RequestCalibration(e.ID, <span class="keyword">true</span>);
                }
</pre></div><p>In the above, the handler then creates, for the new user, a new user entry in the <a class="el" href="smpl__user__tracker__net.html#utcs_init_joints_array">Initializes the 'joints' Array</a> <code>joints</code> array. This is a database for users and skeletons. In this database, each user has a list of entries where each entry is a data pair: </p>
<div class="fragment"><pre class="fragment">
			    &lt;SkeletonJoint, SkeletonJointPosition&gt; 
			</pre></div><p>In the above handler, if the calibration process failed, the handler restarts the whole calibration sequence by calling <a class="el" href="classxn_1_1_pose_detection_capability.html#a8ba21d0b1a6ba12a89fd0100e980121a" title="Starts attempting to detect a pose for a specific user.">xn::PoseDetectionCapability::StartPoseDetection()</a> "StartPoseDetection()".</p>
<h3><a class="anchor" id="utcs_posedetect_ev_hndlr">
'Pose Detected' event handler</a></h3>
<p>The <b>'Pose Detected' event</b> signals that a human user made the pose named in the call to the StartPoseDetection() method. The user is designated with the ID given by the <code>e.ID</code> parameter.</p>
<p>The <b>'Pose Detected' event handler</b> is as below. It's processing is as follows. Now that a pose has been detected, the handler calls <a class="el" href="classxn_1_1_pose_detection_capability.html#a5ecc3fc3aa1fbd7fbe0a01d3d0c105bc">StopPoseDetection()</a> to stop pose detection. The handler then calls <a class="el" href="classxn_1_1_skeleton_capability.html#a3428d28764b594a2816f5aa314188234">xn::SkeletonCapability::RequestCalibration()</a> to start calibration. The <code>true</code> disregards any previous calibration and forces a new calibration. </p>
<div class="fragment"><pre class="fragment">                <span class="keywordtype">void</span> poseDetectionCapability_PoseDetected(<span class="keywordtype">object</span> sender, PoseDetectedEventArgs e)
                {
                    this.poseDetectionCapability.StopPoseDetection(e.ID);
                    this.skeletonCapbility.RequestCalibration(e.ID, <span class="keyword">true</span>);
                }
</pre></div><h3><a class="anchor" id="utcs_newuser_ev_hndlr">
'New User' event handler</a></h3>
<p>The <b>'New User' event</b> signals that a new user has now been recognized in the scene. A new user is a user that was not previously recognized in the scene, and is now recognized in the scene.</p>
<p>The <b>'New User' event handler</b> is as below. It's processing is as follows. Now that a new user has been detected, if a pose is required the handler calls <a class="el" href="classxn_1_1_pose_detection_capability.html#a8ba21d0b1a6ba12a89fd0100e980121a" title="Starts attempting to detect a pose for a specific user.">xn::PoseDetectionCapability::StartPoseDetection()</a> "StartPoseDetection()" to start pose detection. If a pose is not required, the handler requests calibration immediately. </p>
<div class="fragment"><pre class="fragment">                <span class="keywordtype">void</span> userGenerator_NewUser(<span class="keywordtype">object</span> sender, NewUserEventArgs e)
                {
                    <span class="keywordflow">if</span> (this.skeletonCapbility.DoesNeedPoseForCalibration)
                 {
                    this.poseDetectionCapability.StartPoseDetection(this.calibPose, e.ID);
                    }
                <span class="keywordflow">else</span>
                {
                 this.skeletonCapbility.RequestCalibration(e.ID, <span class="keyword">true</span>);
             }
</pre></div><h3><a class="anchor" id="utcs_lostuser_ev_hndlr">
'Lost User' event handler</a></h3>
<p>The <b>'Lost User' event</b> signals that a user has been lost from the list of previously recognized users in the scene. The exact meaning of a lost user is decided by the developer of the <a class="el" href="classxn_1_1_user_generator.html">xn::UserGenerator</a>. However, a typical implementation would define that a lost user is a previously recognized user that then exits the scene and does not return, even after a 'Lost User' timeout has elapsed. Thus this event is raised only after some delay after the user actually exited the scene.</p>
<p>The <b>'Lost User' event handler</b> is as below. It's processing is as follows. Now that an existing user has been lost, the handler deletes the user's entry from the <a class="el" href="smpl__user__tracker__net.html#utcs_init_joints_array">Initializes the 'joints' Array</a> <code>joints</code> array. </p>
<div class="fragment"><pre class="fragment">                <span class="keywordtype">void</span> userGenerator_LostUser(<span class="keywordtype">object</span> sender, UserLostEventArgs e)
                {
                    this.joints.Remove(e.ID);
                }
</pre></div><h2><a class="anchor" id="utcs_calcHist">
CalcHist() - Using the Depth Values to Build an Accumulative Histogram</a></h2>
<p>The program builds this Accumulative Histogram in order to process the maps to display the closer areas more brightly.</p>
<p>The following sequence of code blocks build and process an accumulative histogram of the depth map to increase the contrast of areas of different depths so that closer areas are brighter. The accumulative histogram achieves this by separating out areas of different depth values.</p>
<p>With regards to the actual values contained in the histogram on completion of its preparation for later use, each cell ends up holding a number between 0 and 255, representing the percentage of the pixels that are further away from the sensor than the distance that its index represents (in mm). (This is always 'greater than', and not 'greater than or equal to'). This means, for example, that the furthest distance will have 0, while the closest can have as high as 256.</p>
<p>The following code block uses the depth values to build an accumulative histogram of frequency of occurrence of each depth value. The <code>depthMD.DepthMapPtr()</code>method returns a pointer to the Depth Map to access each value in the depth buffer. The depth value is then used as an index into the histogram[] array.</p>
<div class="fragment"><pre class="fragment">            <span class="keyword">private</span> unsafe <span class="keywordtype">void</span> CalcHist(DepthMetaData depthMD)
            {
                <span class="comment">// reset</span>
                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; this.histogram.Length; ++i)
                    this.histogram[i] = 0;

                ushort* pDepth = (ushort*)depthMD.DepthMapPtr.ToPointer();

                <span class="keywordtype">int</span> points = 0;
                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; depthMD.YRes; ++y)
                {
                    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; depthMD.XRes; ++x, ++pDepth)
                    {
                        ushort depthVal = *pDepth;
                        <span class="keywordflow">if</span> (depthVal != 0)
                        {
                            this.histogram[depthVal]++;
                            points++;
                        }
                    }
                }
</pre></div><p>The following processing loop converts the histogram into a cumulative histogram of frequency of occurrence of each depth value. The cumulative histogram is a histogram in which the vertical axis shows not just the counts for a single depth value, but instead -- for each depth value -- shows the counts for that depth value plus all counts for smaller depth values. The processing loop achieves this by making a running total of the counters of the depth values. Depth values whose counters reach relatively large numbers indicate blobs at those depths. The cumulative total always increases for all depth values each, faster when the depth values are encountered that represent the sides of a blob, and more slowly at a blob's peak. Thus, blobs at significantly different depths are separated out by the histogram to be at significantly different frequency levels. </p>
<div class="fragment"><pre class="fragment">                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt; this.histogram.Length; i++)
                {
                    this.histogram[i] += this.histogram[i-1];
                }
</pre></div><p> Note that at this stage a larger depth value means a greater distance of a human user from the sensor; accordingly, the higher cumulative frequency levels also mean a greater distance. Since we want a greater distance to be presented by a lower brightness (darker color), and a smaller distance to be represented by a greater brightness, then later in the code this direction must be reversed.</p>
<p>The following processing loop normalizes the cumulative histogram by dividing each counter by <code>points</code>, i.e., it converts every counter to a fraction of 1.</p>
<p>This loop also reverses the direction of the histogram - as explained above. This is the term <code>(1.0f&amp;nbsp-&amp;nbsp)</code></p>
<p>So now we have got the brightness factor we need: a smaller distance (depth) is represented by a greater cumulative count for a greater brightness, and larger distance (depth) is represented by a smaller cumulative count for a lower brightness.</p>
<p>The <code>(256&amp;nbsp*&amp;nbsp)</code> multiplier and <code>(int)</code> cast then convert the brightness from a fraction of 1 to an integer between 0 and 255, which is exactly what is needed to directly create an RGB color later in this routine. </p>
<div class="fragment"><pre class="fragment">                <span class="keywordflow">if</span> (points &gt; 0)
                {
                    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt; this.histogram.Length; i++)
                    {
                        this.histogram[i] = (int)(256 * (1.0f - (this.histogram[i] / (<span class="keywordtype">float</span>)points)));
                    }
                }
            }
</pre></div><p>The histogram calculation has now been completed. We now have a <code> histogram[]</code> array that when indexing it with a depth value returns you a brightness value that is larger than the brightness value returned by indexing with a smaller depth value.</p>
<h2><a class="anchor" id="utcs_drawing_the_ske">
Drawing the Complete Skeleton</a></h2>
<p>The following sections show how to get all the individual joints, and then use them to draw a complete skeleton.</p>
<h2><a class="anchor" id="utcs_get_joint">
GetJoint() method</a></h2>
<p>The <code>GetJoint()</code> method is called multiple times by the <code>GetJoints()</code> method (see further below), where each call gets one of the joints of a skeleton and adds it into the easy-to-access <code>joints</code> Dictionary object.</p>
<p>In OpenNI, some of these <em>joints</em> are actual joints, in the conventional sense as termed by the English language, for example, SkeletonJoint.LeftElbow and XN_SKEL_LEFT_WRIST; and other joints are in fact <em>limbs</em>, for example, XN_SKEL_HEAD and XN_SKEL_LEFT_HAND. However, OpenNI defines all these as <em>joints</em>, each joint with a single position coordinate. </p>
<div class="fragment"><pre class="fragment">            <span class="keyword">private</span> <span class="keywordtype">void</span> GetJoint(<span class="keywordtype">int</span> user, SkeletonJoint joint)
            {
                SkeletonJointPosition pos = this.skeletonCapbility.GetSkeletonJointPosition(user, joint);
                <span class="keywordflow">if</span> (pos.Position.Z == 0)
                {
                    pos.Confidence = 0;
                }
                <span class="keywordflow">else</span>
                {
                    pos.Position = this.depth.ConvertRealWorldToProjective(pos.Position);
                }
                this.joints[user][joint] = pos;
            }
</pre></div><p> The above statements are explained separately, as follows.</p>
<p>The <a class="el" href="classxn_1_1_skeleton_capability.html#ace0584aa486fc94580003f658a88466c">getSkeletonJointPosition()</a> method gets the <code>SkeletonJointPosition</code> position of one of the skeleton joints in the most recently generated data for a specified user. The user is specified by its interger ID number, which is of type <a class="el" href="_xn_types_8h.html#a83a03695bbf1ac00ac01d39ad21f01aa">xn::XnUserID</a>. </p>
<div class="fragment"><pre class="fragment">            SkeletonJointPosition pos = this.skeletonCapbility.GetSkeletonJointPosition(user, joint);
</pre></div><p>A sanity check is then performed to check that the joint does not have zero depth, since translation between coordinate systems does not work with a depth zero. </p>
<div class="fragment"><pre class="fragment">            <span class="keywordflow">if</span> (pos.Position.Z == 0)
</pre></div><p>If the position is not zero depth, a new <code>SkeletonJointPosition</code> object is created for the joint and inserted into the <b>joints</b> mapping table. The position structure comprises a 3D position, <a class="el" href="_xn_types_8h.html#a8829e6593cf93cdad7a22a1e4e44e0fe">XnVector3D</a>, and a confidence that the joint is in fact in that position. the <a class="el" href="_xn_types_8h.html#a8829e6593cf93cdad7a22a1e4e44e0fe">3D position struct</a> is a projective coordinate, so the <a class="el" href="classxn_1_1_depth_generator.html#a70cda9f296d0ac90088cfafc34e9edd2">convertRealWorldToProjective()</a> is used to convert the real world coordinate to a projective coordinate. </p>
<div class="fragment"><pre class="fragment">            pos.Position = this.depth.ConvertRealWorldToProjective(pos.Position);
            this.joints[user][joint] = pos;
</pre></div><h2><a class="anchor" id="utcs_get_joints">
GetJoints() method</a></h2>
<p>This method comprises successive calls to the GetJoint() method to get all the joints in a skeleton. The following code block shows the first few statements in this method, which get the Head and Neck joints. The subsequent statements get the rest of the joints. </p>
<div class="fragment"><pre class="fragment">            <span class="keyword">private</span> <span class="keywordtype">void</span> GetJoints(<span class="keywordtype">int</span> user)
            {
                GetJoint(user, SkeletonJoint.Head);
                GetJoint(user, SkeletonJoint.Neck);
                 ... 
            }
</pre></div><h2><a class="anchor" id="utcs_draw_line">
drawLine() method</a></h2>
<p>This method draws a limb of the avatar representation of a human user by drawing a line between two adjacent OpenNI <a class="el" href="_xn_types_8h.html#a7713dc7b4e1415ffe6c835c5979d65f4">joints</a> passed as parameters to this function. The two joints are points in the scene, thus this function draws a line between the two points, i.e., between the current positions of two joints. The two adjacent joints come from the global <code>joints</code> mapping table through the <em>dict</em> parameter. </p>
<div class="fragment"><pre class="fragment">            <span class="keyword">private</span> <span class="keywordtype">void</span> DrawLine(Graphics g, Color color, Dictionary&lt;SkeletonJoint, SkeletonJointPosition&gt; dict, SkeletonJoint j1, SkeletonJoint j2)
            {
                ...
            }
</pre></div><p>In the above, the <code>dict</code> parameter passes in the mapping list of joint-to-position for all the joints of a apecified user. The <code>dict</code> parameter is of type <code>Dictionary&lt;SkeletonJoint, SkeletonJointPosition&gt; dict</code>. The two parameters <code>j1</code> and <code>j2</code> are both enum types, specifying a particular joint in the skeleton. <code>j1</code> and <code>j2</code> are used to index the <code>dict</code> list to get the corresponding positions of the joints.</p>
<p>Statements of this function are explained below.</p>
<p>First, the method checks confidence, which is the likelihood that a point is real, and if either of them have a zero confidence the method fails. </p>
<div class="fragment"><pre class="fragment">            Point3D pos1 = dict[j1].Position;
            Point3D pos2 = dict[j2].Position;

            <span class="keywordflow">if</span> (dict[j1].Confidence == 0 || dict[j2].Confidence == 0)
                <span class="keywordflow">return</span>;
</pre></div><p>The following code block draws the avatar's limb by drawing a line between the two adjacent points. It uses the locations <code>pos1 </code> and <code>pos2</code> obtained above. </p>
<div class="fragment"><pre class="fragment">            g.DrawLine(<span class="keyword">new</span> Pen(color),
                        <span class="keyword">new</span> Point((<span class="keywordtype">int</span>)pos1.X, (<span class="keywordtype">int</span>)pos1.Y),
                        <span class="keyword">new</span> Point((<span class="keywordtype">int</span>)pos2.X, (<span class="keywordtype">int</span>)pos2.Y));               
</pre></div><h2><a class="anchor" id="utcs_draw_skel">
DrawSkeleton() method</a></h2>
<p>This method draws the complete skeleton for a specified user. It draws the skeleton by callng the drawLine() method successive times to draw connecting lines between each adjacent pair of joints. The following code block shows some sample statements: </p>
<div class="fragment"><pre class="fragment">            <span class="keyword">private</span> <span class="keywordtype">void</span> DrawSkeleton(Graphics g, Color color, <span class="keywordtype">int</span> user)
            {
                GetJoints(user);
                Dictionary&lt;SkeletonJoint, SkeletonJointPosition&gt; dict = this.joints[user];

                DrawLine(g, color, dict, SkeletonJoint.Head, SkeletonJoint.Neck);
                  ...         
                DrawLine(g, color, dict, SkeletonJoint.Neck, SkeletonJoint.LeftShoulder);
            }
</pre></div><p>The first few statements are explained in the following.</p>
<p>The <code>GetJoints(user)</code> call builds the complete <code>joints</code> list of all of the specified user's joints, that is to say, for the whole skeleton. GetJoints(user); </p>
<div class="fragment"><pre class="fragment">            GetJoints(user);                
</pre></div><p>The <code>dict</code> parameter is then assigned with this list of joints. Dictionary&lt;SkeletonJoint, SkeletonJointPosition&gt; dict = this.joints[user]; </p>
<div class="fragment"><pre class="fragment">            Dictionary&lt;SkeletonJoint, SkeletonJointPosition&gt; dict = this.joints[user];
</pre></div><p>A call to the DrawLine() method then passes two adjacent joint specifiers as parameters, which are used to select two joint entries from the dict list of joints. The DrawLine() method uses these joints to then draw a line -- or wire -- between the positions of the two joints -- for example, Head and Neck, as shown below -- to make one wire of the skeleton wire frame. </p>
<div class="fragment"><pre class="fragment">            DrawLine(g, color, dict, SkeletonJoint.Head, SkeletonJoint.Neck);
</pre></div><p> The method then draws a further wire, later on, to connect the Neck to a Shoulder, as shown below. </p>
<div class="fragment"><pre class="fragment">            DrawLine(g, color, dict, SkeletonJoint.Neck, SkeletonJoint.LeftShoulder);
</pre></div><h2><a class="anchor" id="utcs_reader_thread">
ReaderThread() method</a></h2>
<p>ReaderThread() is the main run-time method. it manages getting the skeleton tracking data and then calling the DrawSkeleton() method to print the skeleton on the graphic display.</p>
<h3><a class="anchor" id="utcs_getdata_from_dg_node">
Gets Data from the DepthGenerator Node</a></h3>
<p>The following declares a metadata object to provide a frame object for the <a class="el" href="classxn_1_1_depth_generator.html">xn::DepthGenerator</a> node. A <a class="el" href="glossary.html#dict_gen_node">generator node's</a> <a class="el" href="glossary.html#glos_frame_object">frame object</a> contains generated data frame and all its associated properties. This data frame and its properties are accessible through the node's metadata object. </p>
<div class="fragment"><pre class="fragment">                DepthMetaData depthMD = <span class="keyword">new</span> DepthMetaData();
</pre></div><p>Following is the program's main processing loop. All of the remaining code in the ReaderThread() method is located in this loop. </p>
<div class="fragment"><pre class="fragment">                <span class="keywordflow">while</span> (this.shouldRun)
                {
                    <span class="keywordflow">try</span>
                    {   
                        this.context.WaitOneUpdateAll(this.depth);
                    }
                    ...
                    ...
                }                   
</pre></div><p>The first statement in the loop, shown above, calls the <a class="el" href="classxn_1_1_context.html#ad4bab84f35a855639d485da99a05c585">WaitOneUpdateAll()</a> method in the following statement waits for a specified node to have generated a new data frame. The method then refreshes the data of all nodes in the entire production graph. The application can then get the data (for example, using a metadata GetData() method). This method has a timeout. </p>
<div class="fragment"><pre class="fragment">                this.context.WaitOneUpdateAll(this.depth);code  
        
            The following statement places the latest data generated in an <span class="stringliteral">&#39;easy-to-access&#39;</span> buffer. In OpenNI terminology: <span class="stringliteral">&quot;the node&#39;s getMetaData() method gets the node&#39;s data that is designated as &#39;metadata to be placed in the node&#39;s metadata object&#39;&quot;</span>. The code copies the node<span class="stringliteral">&#39;s frame data and configuration to a metadata object - (&lt;code&gt;depthMD&lt;/code&gt;). This metadata object is then termed the &#39;</span>frame <span class="keywordtype">object</span><span class="stringliteral">&#39;.</span>
<span class="stringliteral">            @code</span>
<span class="stringliteral">                this.depth.GetMetaData(depthMD);</span>
</pre></div><p>The following statement calls CalcHist() to calculate the histogram. The histogram stores the frequency of occurence of all depth values. </p>
<div class="fragment"><pre class="fragment">                CalcHist(depthMD);
</pre></div><p>The rest of the code is within the 'lock' block </p>
<div class="fragment"><pre class="fragment">            lock (<span class="keyword">this</span>)
            {
                ...
                
                <span class="keywordflow">if</span> (this.shouldDrawPixels)
                { 
                 ...
                }
            }               
</pre></div><p>The following describes code inside the above <code>'if'</code> block.</p>
<h3><a class="anchor" id="utcs_nestedforloop">
Nested For-loop for Getting Depth and Label Pixels and Displaying them as RGB pixels</a></h3>
<p>The following statement defines and sets a pointer to iterate through the entire data frame got from the <a class="el" href="classxn_1_1_depth_generator.html">DepthGenerator</a> node. This is a pointer to a <a class="el" href="conc__map__wrapper__classes.html">light wrapper object</a>. Note that this is not the depth metadata. {Why not use the depth metadata object?} </p>
<div class="fragment"><pre class="fragment">                ushort* pDepth = (ushort*)this.depth.DepthMapPtr.ToPointer();
</pre></div><p>The following statement defines and sets a pointer to iterate through the entire User Labels map got from the <a class="el" href="classxn_1_1_user_generator.html">UserGenerator</a> node. This is a pointer to a <a class="el" href="conc__map__wrapper__classes.html">light wrapper object</a>. </p>
<div class="fragment"><pre class="fragment">                ushort* pLabels = (ushort*)this.userGenerator.GetUserPixels(0).LabelMapPtr.ToPointer();
</pre></div><p>The above statement sets up a pointer to the User Labels Map. This parallels the Depth map (same x-y dimensions) and identifies which specific user is associated with each pixel. This is needed since each user blob (in the scene) contains an area of pixels, and so applications need to know which user each pixel is part of. Each pixel of the User Labels Map is an integer specifying a user ID. This user ID is the 'label'. Thus, the User Labels Map is a map of the pixels of the entire scene, where each pixel identifies the user it is owned by. If the value of a pixel (in the User Label map) is zero then that means that the pixel is not part of any user and so is part of the background.</p>
<p>The following loops iterate both depth map and label map, both being the same size, the label determines the color and the depth (through the histogram) determines the brightness.</p>
<h3><a class="anchor" id="utcs_nestedforloop_for_disp_userID">
Nested For-loop Displaying User IDs</a></h3>
<p>The application then prints a status report for each user in the scene at the position of the user.</p>
<p>The following statement is part of the setup for the nested for-loop for displaying user IDs on the center of the display images. This makes an array of all the users currently in the scene. </p>
<div class="fragment"><pre class="fragment">                    <span class="keywordtype">int</span>[] users = this.userGenerator.GetUsers();
</pre></div><p>For each user in the array, the main routine loop is performed.</p>
<p>The application displays the status report at the user's position. To do this, the application must first get the position of the user's center of mass (CoM). This is the single point for representing the user. This is done by calling the <a class="el" href="classxn_1_1_user_generator.html">xn::UserGenerator</a> node's xn::UserGenerator::getUserCoM() "getUserCoM()" method for each user. The CoM must then be converted to projective coordinates using the <a class="el" href="classxn_1_1_depth_generator.html#a70cda9f296d0ac90088cfafc34e9edd2">convertRealWorldToProjective()</a> method provided by the <a class="el" href="classxn_1_1_depth_generator.html">DepthGenerator</a> node. </p>
<div class="fragment"><pre class="fragment">                    <span class="keywordflow">foreach</span> (<span class="keywordtype">int</span> user <span class="keywordflow">in</span> users)
                    {
                        <span class="keywordflow">if</span> (this.shouldPrintID)
                        {
                            Point3D com = this.userGenerator.GetCoM(user);
                            com = this.depth.ConvertRealWorldToProjective(com);
                            ...
                            
                        }
                        ...
                    }
</pre></div><p>The following statements access the status of each user to report them on top of each coresponding user image that is displayed on the output display device.</p>
<div class="fragment"><pre class="fragment">                    <span class="keywordtype">string</span> label = <span class="stringliteral">&quot;&quot;</span>;
                    <span class="keywordflow">if</span> (!this.shouldPrintState)
                        label += user;
                    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (this.skeletonCapbility.IsTracking(user))
                        label += user + <span class="stringliteral">&quot; - Tracking&quot;</span>;
                    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (this.skeletonCapbility.IsCalibrating(user))
                        label += user + <span class="stringliteral">&quot; - Calibrating...&quot;</span>;
                    <span class="keywordflow">else</span>
                        label += user + <span class="stringliteral">&quot; - Looking for pose&quot;</span>;

                    g.DrawString(label, <span class="keyword">new</span> Font(<span class="stringliteral">&quot;Arial&quot;</span>, 6), <span class="keyword">new</span> SolidBrush(anticolors[user % ncolors]), com.X, com.Y);
</pre></div><p>Each of the above cases is a different state, as described below. A label is set up depending on the state, and then displayed on the screen at the user position.</p>
<p>the <a class="el" href="classxn_1_1_skeleton_capability.html#a3d377a980e3c34cc12fd5354ceda89f2">IsTracking()</a> method returns whether a user is currently being tracked. A calibrated user means that the human user's limbs have been measured and the calibration data is available. </p>
<div class="fragment"><pre class="fragment">                    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (this.skeletonCapbility.IsTracking(user))
</pre></div><p>the <a class="el" href="classxn_1_1_skeleton_capability.html#aa86d9246c806eacb6fd626290d4cf0e7">IsCalibrating ()</a> method returns whether a user is currently being calibrated. </p>
<div class="fragment"><pre class="fragment">                    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (this.skeletonCapbility.IsCalibrating(user))
</pre></div><p>If a skeleton is not being calibrated or tracked, then in this implementation, the <a class="el" href="classxn_1_1_skeleton_capability.html">xn::SkeletonCapability</a> is looking for a pose, which is the assumed meaning of the catch-all branch of the if-then-else, as follows. </p>
<div class="fragment"><pre class="fragment">                    <span class="keywordflow">else</span>
                        label += user + <span class="stringliteral">&quot; - Looking for pose&quot;</span>;
</pre></div><p>The application then displays the status starting at the CoM position of the user as follows. </p>
<div class="fragment"><pre class="fragment">                    g.DrawString(label, <span class="keyword">new</span> Font(<span class="stringliteral">&quot;Arial&quot;</span>, 6), <span class="keyword">new</span> SolidBrush(anticolors[user % ncolors]), com.X, com.Y);
</pre></div><p>Finally, if a user is being tracked, its skeleton is drawn. This is checked with the <a class="el" href="classxn_1_1_skeleton_capability.html#a3d377a980e3c34cc12fd5354ceda89f2">xn::SkeletonCapability::IsTracking()</a> method. </p>
<div class="fragment"><pre class="fragment">                    <span class="keywordflow">if</span> (this.shouldDrawSkeleton &amp;&amp; this.skeletonCapbility.IsTracking(user))
                        DrawSkeleton(g, anticolors[user % ncolors], user);
</pre></div> </div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Wed Jun 13 21:55:36 2012 for OpenNI 1.5.4 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
