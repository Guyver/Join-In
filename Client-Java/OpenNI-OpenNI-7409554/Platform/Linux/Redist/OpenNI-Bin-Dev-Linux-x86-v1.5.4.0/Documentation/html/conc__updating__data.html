<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>OpenNI 1.5.4: Making Data Available using the WaitXUpdateAll() Methods</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="main.html">OpenNI Overview</a>&nbsp;&raquo;&nbsp;<a class="el" href="concepts.html">Concepts</a>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="conc_updating_data">Making Data Available using the WaitXUpdateAll() Methods </a></h1><p>Generator nodes can be generating new data all the time. Meanwhile, however, an application typically needs to be using one consistent data set (data frame and associated data) all received at any one time, until it has completed processing the frame. For this reason, an OpenNI generator holds its new data internally only, until the application explicitly asks the generator to update its data to the new data. This request is done by an 'Update Data' command. OpenNI API provides the <a class="el" href="classxn_1_1_generator.html#aaf3162a87a79a05fa655f344c835fa2e">xn::Generator::WaitAndUpdateData()</a> method to let the application wait for the generator to have generated new data. This method causes it to be 'updated', which means that it copies it to the node's application buffer.</p>
<p>In some cases, the production graph comprises of more than one node, and the application will usually want all the nodes to be updated at once. OpenNI supplies a family of methods &ndash; called the <code>WaitXUpdateAll()</code> methods &ndash; to update the nodes all at once, depending on which approach the application wants to use to update the nodes. For a summary of the <b>WaitXUpdateAll</b> methods, see <a class="el" href="conc__updating__data.html#conc_updating_data__summary_of_wait_fns">'Wait and Update' Methods</a> below.</p>
<p>Unless needing to update only a specific node, it is highly advised to use one of the '<code>Update All</code>' functions. In addition, for updating all the nodes these '<code>Update All</code>' functions have some further benefits:</p>
<ul>
<li>If nodes are dependent on each other, it promises that the needed node will be updated before the needing node.</li>
</ul>
<ul>
<li>If playing a recording, it reads data from the recording until the condition is met.</li>
</ul>
<ul>
<li>If a recorder exists, it records the data from all nodes added to it (without the need to call <a class="el" href="classxn_1_1_recorder.html#a94a2c702fd2c5e2466b813bb585e6fc9">xn::Recorder::Record()</a>).</li>
</ul>
<h2><a class="anchor" id="conc_updating_data__summary_of_wait_fns">
'Wait and Update' Methods</a></h2>
<p>The 'WaitXandUpdateAll' methods are a family of methods of the <a class="el" href="classxn_1_1_context.html">Context</a> class that act on the entire production graph, i.e., they act on each and every one of the generator nodes in the context. Calling a 'WaitXandUpdateAll' method 'updates' the nodes, that is, the method ensures that the accessible data from each and every node is the node's most recently generated data.</p>
<p>Each of the 'WaitXandUpdateAll' methods performs a different type of 'wait' prior to performing the 'update' &ndash; see below for separate descriptions of each of these methods.</p>
<ul>
<li><a class="el" href="group__context.html#ga1f368415a33e776cb8fb9abbb355182d">xnWaitAndUpdateAll()</a> (<a class="el" href="classxn_1_1_context.html#a52929d2a535166b18098e066900f9d59">xn::Context::WaitAndUpdateAll()</a>) - Updates all generator nodes in the context, first waiting for each node to have new data available.</li>
</ul>
<ul>
<li><a class="el" href="group__context.html#ga2b049d7bd9675d27768ae9774c0c57fb">xnWaitAnyUpdateAll()</a> (<a class="el" href="classxn_1_1_context.html#a17fab043d7b6d60728511527a1d5c090">xn::Context::WaitAnyUpdateAll()</a>) - Waits for any node to have new data. Once new data is available from any node, all nodes are updated.</li>
</ul>
<ul>
<li><a class="el" href="group__context.html#gaef6d1bace02687ad46df674a3a038d49">xnWaitOneUpdateAll()</a> (<a class="el" href="classxn_1_1_context.html#ad4bab84f35a855639d485da99a05c585">xn::Context::WaitOneUpdateAll()</a>) - Waits for a specific node to have new data. Once new data is available from this node, all nodes are updated. This is especially useful when having several nodes producing data, but only one determines the progress of the application.</li>
</ul>
<ul>
<li><a class="el" href="group__context.html#ga39193a7b6a4809b6f5db8af22796c415">xnWaitNoneUpdateAll()</a> (<a class="el" href="classxn_1_1_context.html#ae498b727aa0fdade75f91bdb2563f88c">xn::Context::WaitNoneUpdateAll()</a>) - Does not wait for anything. All nodes are updated.</li>
</ul>
<p>There is also a WaitAndUpdateData() method that is a member of a specific node. This is a member of the <a class="el" href="classxn_1_1_generator.html">xn::Generator</a> class. The difference between them is that the 'WaitXAndUpdateData' methods update the application buffers of all the nodes in the entire context all at once, specifying which type of wait to perform first. In contrast, the <a class="el" href="classxn_1_1_generator.html#aaf3162a87a79a05fa655f344c835fa2e">xn::Generator::WaitAndUpdateData()</a> method waits only on the specified node and then updates its application buffer.</p>
<h2><a class="anchor" id="conc_updating_data__in_depth">
In Depth</a></h2>
<p>It is understood from the above that even when nodes are generating data, the application cannot get any of their new data until it calls one of these 'wait and update' methods. Typically, a call to one of these methods will be placed in the main program loop.</p>
<p>Note that these methods are not one-off calls for setting a mode for all future updates. As already mentioned, one of these methods must be called each time the application wishes to cause new generated data to be output.</p>
<p>These methods exit after a timeout of two seconds.</p>
<p>The nodes output their next new generated data items in their order of dependencies, i.e., these methods guarantee that the 'server' node (the lower-level node generating the data for another node) is updated before the 'client' node.</p>
<p>When <a class="el" href="classxn_1_1_player.html">Player</a> playing data from a recording, depending on the mode, these methods read data from the recreated nodes exactly as for live nodes.</p>
<p>If a recorder exists, these methods automatically record the data from all nodes added to this recorder.</p>
<h2><a class="anchor" id="conc_updating_data__sample_code_cmn">
Sample Code</a></h2>
<p>Here is an example of updating data and getting data. This particular example uses a node with an associated <a class="el" href="glossary.html#glos_frame_object">frame </a> object". The frame object is contained in a @ref conc_meta_data 
	"metadata" object.</p>
<p>After calling an 'Update Data' method (in this example, the node's <a class="el" href="classxn_1_1_generator.html#aaf3162a87a79a05fa655f344c835fa2e">WaitAndUpdateData()</a> method), the application must call the node's <code>GetMetaData()</code> method to get the node's latest generated frame object and save it as metadata.</p>
<p>The node's <code>GetMetaData()</code> method gets the node's frame object that is. An example of a metadata object is <a class="el" href="classxn_1_1_depth_meta_data.html">xn::DepthMetaData</a>, which is the metadata object for a <a class="el" href="classxn_1_1_depth_generator.html">DepthGenerator</a> node.</p>
<p><b>Code example: </b></p>
<div class="fragment"><pre class="fragment">    DepthGenerator depth;
    depth.StartGenerating();

    DepthMetaData depthMD;
    <span class="keywordflow">while</span> forever
    { 
        depth.WaitAndUpdateData();  
        depth.GetMetaData(depthMD); 
        
        XnUInt32 xRes = depthMD.XRes();
        <span class="keyword">const</span> <a class="code" href="_xn_types_8h.html#ad55e431b82556504d5c1c00d153156c9">XnDepthPixel</a>* pDepthMap = depthMD.Data();
    }
</pre></div><p>Note that for each 'Update Data' call (e.g., <a class="el" href="classxn_1_1_generator.html#aaf3162a87a79a05fa655f344c835fa2e">xn::Generator::WaitAndUpdateData()</a> above) the application must then again get the new data (using the node's <code>GetMetaData()</code> method). This is true also when accessing the data through metadata. That is, the metadata is not permanently attached to the node's new output.</p>
<p>In some cases, the production graph comprises of more than one node, and the application will usually want all the nodes to be updated at once. OpenNI supplies a family of methods &amp;nbsp called the <code>WaitXUpdateAll()</code> methods &amp;nbsp to update the nodes all at once. For more information on the <code>WaitXUpdateAll()</code> methods see <a class="el" href="conc__updating__data.html">Making Data Available using the WaitXUpdateAll() Methods</a>. </p>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Wed Jun 13 21:55:35 2012 for OpenNI 1.5.4 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
