<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>OpenNI 1.5.4: Creating a Node Exporter</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="main.html">OpenNI Overview</a>&nbsp;&raquo;&nbsp;<a class="el" href="smpls__n__guides.html">Samples and Guides</a>&nbsp;&raquo;&nbsp;<a class="el" href="guides.html">Guides for OpenNI Development</a>&nbsp;&raquo;&nbsp;<a class="el" href="modules__root.html">Creating OpenNI Modules</a>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="modules_exporter">Creating a Node Exporter </a></h1><p>Once you have completed your node implementation class, you must create a node exporter class to export your new node to OpenNI. The node exporter is a factory that allows (i) enumerating existing nodes, (ii) creating new nodes, and (iii) destroying nodes.</p>
<p>Creating a node exporter is done by defining a new class that inherits from <a class="el" href="classxn_1_1_module_exported_production_node.html">xn::ModuleExportedProductionNode</a>.</p>
<h2><a class="anchor" id="modules_exporter_desc">
Node Description</a></h2>
<p>Each node implementation has a description. The description contains the following information:</p>
<ul>
<li>Node Type (Depth Generator / Device / Hands Generator, etc.)</li>
<li>Vendor Name</li>
<li>Node Name (to distinguish two products from the same vendor)</li>
<li>Version</li>
</ul>
<p>This description should be unique to each node implementation.</p>
<h2><a class="anchor" id="modules_exporter_enum">
Enumeration</a></h2>
<p>The enumeration process is where production graphs are created. When an application asks for a node of a specific type, OpenNI enumerates the node exporters which declared this type. The node exporter is responsible of returning the list of production graphs that can be created in order to have such a node. Of course, each such production graph will have your node implementation as its root.</p>
<p>The enumeration process is the opportunity to:</p>
<ul>
<li>Check if a specific hardware is attached and ready for operation. For example, an exporter of a device node will usually<ul>
<li>Query the operating system to find out if a specific USB device is connected right now.</li>
<li>Check if this hardware is not already in use by another software component, and so cannot be used.</li>
<li>If more than one device is connected, it can return two different production graph alternatives, one for each such device.</li>
</ul>
</li>
<li>Check that a valid license exists to use the node implementation.</li>
<li>Enumerate nodes from another type that are required for this node implementation to function.</li>
</ul>
<p>A production graph alternative is represented by a <a class="el" href="classxn_1_1_node_info.html">xn::NodeInfo</a> object. It contains a description of the node (must be the same as the description returned by the <a class="el" href="classxn_1_1_module_exported_production_node.html#ad6f40b95e7b8efddb338e7c4088ce9bd">xn::ModuleExportedProductionNode::GetDescription()</a> method), an optional creation info and a list of dependent nodes (through which the entire graph can be described).</p>
<p>Adding production graphs to the list is usually done using the <a class="el" href="classxn_1_1_node_info_list.html#a3df77553f1089ac85470615c66c62a20">xn::NodeInfoList::Add()</a> method.</p>
<p>Note that one of the returned production graph alternatives might be used later on to create the production graph, so it's important that this alternative will fully describe the exact instance to be created. If two alternatives only differ in the way the root node (your node implementation) is created, the difference can be described in the <em>creation info</em> member.</p>
<p>If the node implementation depends on exactly one input node, it can use the <a class="el" href="classxn_1_1_context.html#adbac4aa85e6f9b0820925cc5e6d763bd">xn::Context::AutoEnumerateOverSingleInput()</a> utility method.</p>
<p>If no production graphs alternatives are currently available, besides returning an empty list, it is also advised to return a return value other than XN_STATUS_OK. This return value will be added to the EnumerationErrors object, so that the application can later on check why a specific node failed to enumerate.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Current OpenNI interface can not pass state while enumerating. This causes a problem if production graph cycles might occur (for example, if a depth generator enumerates for depth generator, or if a hands generator enumerates for user generator which itself enumerates for hands generator). Right now, the best solution is to use a static boolean inside your Enumerate() implementation, to recognize if the method is called recursively, and if so, return nothing.</dd></dl>
<h2><a class="anchor" id="modules_exporter_create">
Creating the Node</a></h2>
<p>Once enumeration is complete, the application can choose one of the returned production graphs alternatives and ask OpenNI to create it. OpenNI assures the node exporter that all needed nodes in the production graphs will be created before calling to <a class="el" href="classxn_1_1_module_exported_production_node.html#ae8344d27f82e2b7da3b5dee16294795d">xn::ModuleExportedProductionNode::Create()</a>, so that the exporter can take those nodes and use them. In addition to the information found in the NodeInfo object (needed nodes, creation info), OpenNI passes to the exporter an instance name (the name that this node will have in OpenNI context), and a configuration dir (taken from the module registration -- see <a class="el" href="modules__registration.html">Registering the new Module</a>).</p>
<p>The exporter should create the node implementation it exports, and return a pointer to it to OpenNI.</p>
<h2><a class="anchor" id="modules_exporter_destroy">
Destroying the Node</a></h2>
<p>Once OpenNI determines that the node is no longer needed, it will request the exporter to destroy it by calling <code><a class="el" href="classxn_1_1_module_exported_production_node.html#aacdbd675bb6cd1a31a5e9c20e8c6e7c9">xn::ModuleExportedProductionNode::Destroy()</a></code>. OpenNI ensures that a node is destroyed before any of the nodes on which it depends in the production graph are destroyed.</p>
<h2><a class="anchor" id="modules_exporter_ex1">
Example A: Exporter for a node which requires a physical device</a></h2>
<p>Let's take for example a device node that represents some USB physical device. The enumeration uses the operating system to find out which devices are connected right now, obtains the path to each device node, and creates a production graph for each device node. The exporter places the device path in the creation info. This allows easy access to the device path so the exporter knows which is the correct device to connect to.</p>
<p>The Create() method takes the creation info and passes it to the device node constructor.</p>
<div class="fragment"><pre class="fragment"><span class="keyword">class </span>MyDevice : <span class="keyword">public</span> <span class="keyword">virtual</span> xn::ModuleDevice
{
<span class="keyword">public</span>:
    MyDevice(<span class="keyword">const</span> XnChar* strDevicePath);
    ...
};

<span class="keyword">class </span>MyDeviceExporter : <span class="keyword">public</span> <span class="keyword">virtual</span> xn::ModuleExportedProductionNode
{
<span class="keyword">public</span>:
    <span class="keyword">virtual</span> <span class="keywordtype">void</span> GetDescription(<a class="code" href="struct_xn_production_node_description.html">XnProductionNodeDescription</a>* pDescription) 
    {
        pDescription-&gt;<a class="code" href="struct_xn_production_node_description.html#a9499efe08226548c89a6684534f0d769">Type</a> = <a class="code" href="_xn_types_8h.html#ac773bbb9817dac5ae1be0f380ec18b52a3f3f170232645dd79fdbe7f7cc4e2097">XN_NODE_TYPE_DEVICE</a>;
        strcpy(pDescription-&gt;<a class="code" href="struct_xn_production_node_description.html#a6b1d091887c8391c974e4ec6c8f2bf48">strVendor</a>, <span class="stringliteral">&quot;New Devices Inc.&quot;</span>);
        strcpy(pDescription-&gt;<a class="code" href="struct_xn_production_node_description.html#ac65ad15c1d36fe884068b210f0ad3f4e">strName</a>, <span class="stringliteral">&quot;MyDevice&quot;</span>);
        pDescription-&gt;<a class="code" href="struct_xn_production_node_description.html#a665ca8c5162fd67029f08963f7899546">Version</a>.<a class="code" href="struct_xn_version.html#a472efc887378bca0cbe490e30b6f80f7">nMajor</a> = 1;
        pDescription-&gt;<a class="code" href="struct_xn_production_node_description.html#a665ca8c5162fd67029f08963f7899546">Version</a>.<a class="code" href="struct_xn_version.html#a03d37d89a944305571c8681eed15058a">nMinor</a> = 0;
        pDescription-&gt;<a class="code" href="struct_xn_production_node_description.html#a665ca8c5162fd67029f08963f7899546">Version</a>.<a class="code" href="struct_xn_version.html#aa3c800490a6d99f038faca0fc6626576">nMaintenance</a> = 0;
        pDescription-&gt;<a class="code" href="struct_xn_production_node_description.html#a665ca8c5162fd67029f08963f7899546">Version</a>.<a class="code" href="struct_xn_version.html#adead3f3f47c9e3dbdc766cad1574a19e">nBuild</a> = 7;
    }

    <span class="keyword">virtual</span> <a class="code" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> EnumerateProductionTrees(Context&amp; context, NodeInfoList&amp; TreesList, EnumerationErrors* pErrors) 
    {
        <a class="code" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> nRetVal = <a class="code" href="_xn_status_8h.html#a92729089d8e28e740a3f8b5169c8f695">XN_STATUS_OK</a>;

        <a class="code" href="struct_xn_production_node_description.html">XnProductionNodeDescription</a> description;
        GetDescription(&amp;description);
        
        <span class="comment">// find which USB device are connected</span>
        <span class="keyword">const</span> <a class="code" href="_xn_u_s_b_8h.html#a9529e5f3d9ae6e4126e5b42a76e69161">XnUSBConnectionString</a>* astrDevicePaths;
        XnUInt32 nCount;

        nRetVal = <a class="code" href="_xn_u_s_b_8h.html#ac5fb02ceb74da39b14561d45f8ad571b">xnUSBEnumerateDevices</a>(MY_VENDOR_ID, MY_PRODUCT_ID, astrDevicePaths, &amp;nCount);
        <a class="code" href="_xn_macros_8h.html#a6116e7b1f42e5ad6123f8fbb70b4bbca">XN_IS_STATUS_OK</a>(nRetVal);
        
        <span class="keywordflow">if</span> (nCount == 0)
        {
            <span class="comment">// no device was found. return an error</span>
            <span class="keywordflow">return</span> XN_STATUS_DEVICE_NOT_CONNECTED;
        }

        <span class="comment">// add a production graph alternative for each connected device</span>
        <span class="keywordflow">for</span> (XnUInt32 i = 0; i &lt; nCount; ++i)
        {
            nRetVal = TreesList.Add(description, astrDevicePaths[i], NULL);
            <a class="code" href="_xn_macros_8h.html#a6116e7b1f42e5ad6123f8fbb70b4bbca">XN_IS_STATUS_OK</a>(nRetVal);
        }

        <a class="code" href="_xn_u_s_b_8h.html#a0ec4128ee87d55dbf470c6de20ae95c4">xnUSBFreeDevicesList</a>(astrDevicePaths);

        <span class="keywordflow">return</span> (<a class="code" href="_xn_status_8h.html#a92729089d8e28e740a3f8b5169c8f695">XN_STATUS_OK</a>);
    }

    <span class="keyword">virtual</span> <a class="code" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> Create(Context&amp; context, <span class="keyword">const</span> XnChar* strInstanceName, <span class="keyword">const</span> XnChar* strCreationInfo, 
                            NodeInfoList* pNeededTrees, <span class="keyword">const</span> XnChar* strConfigurationDir, ModuleProductionNode** ppInstance) 
    {
        *ppInstance = <span class="keyword">new</span> MyDevice(strCreationInfo);
        <span class="keywordflow">if</span> (*ppInstance == NULL)
        {
            <span class="keywordflow">return</span> XN_STATUS_ALLOC_FAILED;
        }

        <span class="keywordflow">return</span> <a class="code" href="_xn_status_8h.html#a92729089d8e28e740a3f8b5169c8f695">XN_STATUS_OK</a>;
    }

    <span class="keyword">virtual</span> <span class="keywordtype">void</span> Destroy(ModuleProductionNode* pInstance) 
    {
        <span class="keyword">delete</span> pInstance;
    }
};
</pre></div><h2><a class="anchor" id="modules_exporter_ex2">
Example B: Exporter for a node which requires one input node</a></h2>
<p>For example, if you want to build a hands generator that works over an RGB image map. The exporter must declare that the node needs an image generator as input.</p>
<div class="fragment"><pre class="fragment"><span class="keyword">class </span>MyHandsGenerator : <span class="keyword">public</span> <span class="keyword">virtual</span> xn::ModuleHandsGenerator
{
<span class="keyword">public</span>:
    MyHandsGenerator(ImageGenerator imageGen);
    ...
};

<span class="keyword">class </span>MyHandsExporter : <span class="keyword">public</span> <span class="keyword">virtual</span> xn::ModuleExportedProductionNode
{
<span class="keyword">public</span>:
    <span class="keyword">virtual</span> <span class="keywordtype">void</span> GetDescription(<a class="code" href="struct_xn_production_node_description.html">XnProductionNodeDescription</a>* pDescription) 
    {
        pDescription-&gt;<a class="code" href="struct_xn_production_node_description.html#a9499efe08226548c89a6684534f0d769">Type</a> = <a class="code" href="_xn_types_8h.html#ac773bbb9817dac5ae1be0f380ec18b52a3f3f170232645dd79fdbe7f7cc4e2097">XN_NODE_TYPE_DEVICE</a>;
        strcpy(pDescription-&gt;<a class="code" href="struct_xn_production_node_description.html#a6b1d091887c8391c974e4ec6c8f2bf48">strVendor</a>, <span class="stringliteral">&quot;New Algorithms Inc.&quot;</span>);
        strcpy(pDescription-&gt;<a class="code" href="struct_xn_production_node_description.html#ac65ad15c1d36fe884068b210f0ad3f4e">strName</a>, <span class="stringliteral">&quot;MyHandsGenerator&quot;</span>);
        pDescription-&gt;<a class="code" href="struct_xn_production_node_description.html#a665ca8c5162fd67029f08963f7899546">Version</a>.<a class="code" href="struct_xn_version.html#a472efc887378bca0cbe490e30b6f80f7">nMajor</a> = 1;
        pDescription-&gt;<a class="code" href="struct_xn_production_node_description.html#a665ca8c5162fd67029f08963f7899546">Version</a>.<a class="code" href="struct_xn_version.html#a03d37d89a944305571c8681eed15058a">nMinor</a> = 0;
        pDescription-&gt;<a class="code" href="struct_xn_production_node_description.html#a665ca8c5162fd67029f08963f7899546">Version</a>.<a class="code" href="struct_xn_version.html#aa3c800490a6d99f038faca0fc6626576">nMaintenance</a> = 0;
        pDescription-&gt;<a class="code" href="struct_xn_production_node_description.html#a665ca8c5162fd67029f08963f7899546">Version</a>.<a class="code" href="struct_xn_version.html#adead3f3f47c9e3dbdc766cad1574a19e">nBuild</a> = 7;
    }

    <span class="keyword">virtual</span> <a class="code" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> EnumerateProductionTrees(Context&amp; context, NodeInfoList&amp; TreesList, EnumerationErrors* pErrors) 
    {
        <a class="code" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> nRetVal = <a class="code" href="_xn_status_8h.html#a92729089d8e28e740a3f8b5169c8f695">XN_STATUS_OK</a>;

        <a class="code" href="struct_xn_production_node_description.html">XnProductionNodeDescription</a> description;
        GetDescription(&amp;description);

        <span class="keywordflow">return</span> context.AutoEnumerateOverSingleInput(
            TreesList,          <span class="comment">// the list to be filled</span>
            description,        <span class="comment">// our description</span>
            NULL,               <span class="comment">// creation info. Not needed in this example.</span>
            <a class="code" href="_xn_types_8h.html#ac773bbb9817dac5ae1be0f380ec18b52a6c93c4744f518c307c7c60f3b86937e4">XN_NODE_TYPE_IMAGE</a>, <span class="comment">// type of the single input required</span>
            pErrors,            <span class="comment">// the EnumerationErrors object</span>
            NULL                <span class="comment">// query. Not needed in this example.</span>
            );
    }

    <span class="keyword">virtual</span> <a class="code" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> Create(Context&amp; context, <span class="keyword">const</span> XnChar* strInstanceName, <span class="keyword">const</span> XnChar* strCreationInfo, 
                            NodeInfoList* pNeededTrees, <span class="keyword">const</span> XnChar* strConfigurationDir, ModuleProductionNode** ppInstance) 
    {
        <a class="code" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> nRetVal = <a class="code" href="_xn_status_8h.html#a92729089d8e28e740a3f8b5169c8f695">XN_STATUS_OK</a>;
        
        <span class="comment">// take the first needed node</span>
        NodeInfoList::Iterator it = pNeededTrees-&gt;Begin();
        <span class="keywordflow">if</span> (it == pNeededTrees-&gt;End())
        {
            xnLogError(<span class="stringliteral">&quot;MyHandsGenerator&quot;</span>, <span class="stringliteral">&quot;Got a production graph different from the one returned in Enumerate()!&quot;</span>);
            <span class="keywordflow">return</span> XN_STATUS_ERROR;
        }

        NodeInfo imageInfo = *it;

        <span class="comment">// make sure its of the right type and that this is the only one</span>
        <span class="keywordflow">if</span> (imageInfo.GetDescription().Type != <a class="code" href="_xn_types_8h.html#ac773bbb9817dac5ae1be0f380ec18b52a6c93c4744f518c307c7c60f3b86937e4">XN_NODE_TYPE_IMAGE</a> || ++it != pNeededTrees-&gt;End())
        {
            xnLogError(<span class="stringliteral">&quot;MyHandsGenerator&quot;</span>, <span class="stringliteral">&quot;Got a production graph different from the one returned in Enumerate()!&quot;</span>);
            <span class="keywordflow">return</span> XN_STATUS_ERROR;
        }

        <span class="comment">// OpenNI assures us the image node is already created</span>
        ImageGenerator image;
        nRetVal = imageInfo.GetInstance(image);
        <a class="code" href="_xn_macros_8h.html#a6116e7b1f42e5ad6123f8fbb70b4bbca">XN_IS_STATUS_OK</a>(nRetVal);

        *ppInstance = <span class="keyword">new</span> MyHandsGenerator(image);
        <span class="keywordflow">if</span> (*ppInstance == NULL)
        {
            <span class="keywordflow">return</span> XN_STATUS_ALLOC_FAILED;
        }

        <span class="keywordflow">return</span> <a class="code" href="_xn_status_8h.html#a92729089d8e28e740a3f8b5169c8f695">XN_STATUS_OK</a>;
    }

    <span class="keyword">virtual</span> <span class="keywordtype">void</span> Destroy(ModuleProductionNode* pInstance) 
    {
        <span class="keyword">delete</span> pInstance;
    }
};
</pre></div><h2><a class="anchor" id="modules_exporter_ex3">
Example C: Exporter for a node which requires two different nodes</a></h2>
<p>Let's take for example a hands generator that needs both RGB information and depth information of the scene. The exporter will create production graph alternatives that require both an ImageGenerator node and a DepthGenerator node.</p>
<div class="fragment"><pre class="fragment"><span class="keyword">class </span>MyHandsGenerator : <span class="keyword">public</span> <span class="keyword">virtual</span> xn::ModuleHandsGenerator
{
<span class="keyword">public</span>:
    MyHandsGenerator(ImageGenerator&amp; imageGen, DepthGenerator&amp; depthGen);
    ...
};

<span class="keyword">class </span>MyHandsExporter : <span class="keyword">public</span> <span class="keyword">virtual</span> xn::ModuleExportedProductionNode
{
<span class="keyword">public</span>:
    <span class="keyword">virtual</span> <span class="keywordtype">void</span> GetDescription(<a class="code" href="struct_xn_production_node_description.html">XnProductionNodeDescription</a>* pDescription) 
    {
        pDescription-&gt;<a class="code" href="struct_xn_production_node_description.html#a9499efe08226548c89a6684534f0d769">Type</a> = <a class="code" href="_xn_types_8h.html#ac773bbb9817dac5ae1be0f380ec18b52a3f3f170232645dd79fdbe7f7cc4e2097">XN_NODE_TYPE_DEVICE</a>;
        strcpy(pDescription-&gt;<a class="code" href="struct_xn_production_node_description.html#a6b1d091887c8391c974e4ec6c8f2bf48">strVendor</a>, <span class="stringliteral">&quot;New Algorithms Inc.&quot;</span>);
        strcpy(pDescription-&gt;<a class="code" href="struct_xn_production_node_description.html#ac65ad15c1d36fe884068b210f0ad3f4e">strName</a>, <span class="stringliteral">&quot;MyHandsGenerator&quot;</span>);
        pDescription-&gt;<a class="code" href="struct_xn_production_node_description.html#a665ca8c5162fd67029f08963f7899546">Version</a>.<a class="code" href="struct_xn_version.html#a472efc887378bca0cbe490e30b6f80f7">nMajor</a> = 1;
        pDescription-&gt;<a class="code" href="struct_xn_production_node_description.html#a665ca8c5162fd67029f08963f7899546">Version</a>.<a class="code" href="struct_xn_version.html#a03d37d89a944305571c8681eed15058a">nMinor</a> = 0;
        pDescription-&gt;<a class="code" href="struct_xn_production_node_description.html#a665ca8c5162fd67029f08963f7899546">Version</a>.<a class="code" href="struct_xn_version.html#aa3c800490a6d99f038faca0fc6626576">nMaintenance</a> = 0;
        pDescription-&gt;<a class="code" href="struct_xn_production_node_description.html#a665ca8c5162fd67029f08963f7899546">Version</a>.<a class="code" href="struct_xn_version.html#adead3f3f47c9e3dbdc766cad1574a19e">nBuild</a> = 7;
    }

    <span class="keyword">virtual</span> <a class="code" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> EnumerateProductionTrees(Context&amp; context, NodeInfoList&amp; TreesList, EnumerationErrors* pErrors) 
    {
        <a class="code" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> nRetVal = <a class="code" href="_xn_status_8h.html#a92729089d8e28e740a3f8b5169c8f695">XN_STATUS_OK</a>;

        <a class="code" href="struct_xn_production_node_description.html">XnProductionNodeDescription</a> description;
        GetDescription(&amp;description);

        <span class="comment">// find production graph alternatives for image</span>
        NodeInfoList imageList;
        nRetVal = context.EnumerateProductionTrees(<a class="code" href="_xn_types_8h.html#ac773bbb9817dac5ae1be0f380ec18b52a6c93c4744f518c307c7c60f3b86937e4">XN_NODE_TYPE_IMAGE</a>, NULL, imageList, pErrors);
        <a class="code" href="_xn_macros_8h.html#a6116e7b1f42e5ad6123f8fbb70b4bbca">XN_IS_STATUS_OK</a>(nRetVal);

        <span class="comment">// find production graph alternatives for depth</span>
        NodeInfoList depthList;
        nRetVal = context.EnumerateProductionTrees(<a class="code" href="_xn_types_8h.html#ac773bbb9817dac5ae1be0f380ec18b52a1415a428ab99e92cebedd4fdb1fe74c6">XN_NODE_TYPE_DEPTH</a>, NULL, depthList, pErrors);
        <a class="code" href="_xn_macros_8h.html#a6116e7b1f42e5ad6123f8fbb70b4bbca">XN_IS_STATUS_OK</a>(nRetVal);

        <span class="comment">// now for each combination, we create one alternative</span>
        <span class="keywordflow">for</span> (NodeInfoList::Iterator imageIt = imageList.Begin(); imageIt != imageList.End(); ++imageIt)
        {
            <span class="keywordflow">for</span> (NodeInfoList::Iterator depthIt = depthList.Begin(); depthIt != depthList.End(); ++depthIt)
            {
                <span class="comment">// create needed nodes list</span>
                NodeInfoList neededNodes;

                nRetVal = neededNodes.AddNodeFromAnotherList(imageIt);
                <a class="code" href="_xn_macros_8h.html#a6116e7b1f42e5ad6123f8fbb70b4bbca">XN_IS_STATUS_OK</a>(nRetVal);

                nRetVal = neededNodes.AddNodeFromAnotherList(depthIt);
                <a class="code" href="_xn_macros_8h.html#a6116e7b1f42e5ad6123f8fbb70b4bbca">XN_IS_STATUS_OK</a>(nRetVal);

                nRetVal = TreesList.Add(
                    description,    <span class="comment">// our description</span>
                    NULL,           <span class="comment">// creation info. not needed in this example</span>
                    &amp;neededNodes    <span class="comment">// needed nodes list</span>
                    );
                <a class="code" href="_xn_macros_8h.html#a6116e7b1f42e5ad6123f8fbb70b4bbca">XN_IS_STATUS_OK</a>(nRetVal);
            }
        }

        <span class="keywordflow">return</span> <a class="code" href="_xn_status_8h.html#a92729089d8e28e740a3f8b5169c8f695">XN_STATUS_OK</a>;
    }

    <span class="keyword">virtual</span> <a class="code" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> Create(Context&amp; context, <span class="keyword">const</span> XnChar* strInstanceName, <span class="keyword">const</span> XnChar* strCreationInfo, 
                            NodeInfoList* pNeededTrees, <span class="keyword">const</span> XnChar* strConfigurationDir, ModuleProductionNode** ppInstance) 
    {
        <a class="code" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> nRetVal = <a class="code" href="_xn_status_8h.html#a92729089d8e28e740a3f8b5169c8f695">XN_STATUS_OK</a>;
        
        <span class="comment">// take the first needed node</span>
        NodeInfoList::Iterator it = pNeededTrees-&gt;Begin();
        <span class="keywordflow">if</span> (it == pNeededTrees-&gt;End())
        {
            xnLogError(<span class="stringliteral">&quot;MyHandsGenerator&quot;</span>, <span class="stringliteral">&quot;Got a production graph different from the one returned in Enumerate()!&quot;</span>);
            <span class="keywordflow">return</span> XN_STATUS_ERROR;
        }

        NodeInfo imageInfo = *it;

        <span class="comment">// take the second needed node</span>
        ++it;
        <span class="keywordflow">if</span> (it == pNeededTrees-&gt;End())
        {
            xnLogError(<span class="stringliteral">&quot;MyHandsGenerator&quot;</span>, <span class="stringliteral">&quot;Got a production graph different from the one returned in Enumerate()!&quot;</span>);
            <span class="keywordflow">return</span> XN_STATUS_ERROR;
        }

        NodeInfo depthInfo = *it;

        <span class="comment">// make sure types are correct and that no more nodes were received</span>
        <span class="keywordflow">if</span> (imageInfo.GetDescription().Type != <a class="code" href="_xn_types_8h.html#ac773bbb9817dac5ae1be0f380ec18b52a6c93c4744f518c307c7c60f3b86937e4">XN_NODE_TYPE_IMAGE</a> || 
            depthInfo.GetDescription().Type != <a class="code" href="_xn_types_8h.html#ac773bbb9817dac5ae1be0f380ec18b52a1415a428ab99e92cebedd4fdb1fe74c6">XN_NODE_TYPE_DEPTH</a> ||
            ++it != pNeededTrees-&gt;End())
        {
            xnLogError(<span class="stringliteral">&quot;MyHandsGenerator&quot;</span>, <span class="stringliteral">&quot;Got a production graph different from the one returned in Enumerate()!&quot;</span>);
            <span class="keywordflow">return</span> XN_STATUS_ERROR;
        }

        <span class="comment">// OpenNI assures us the nodes are already created</span>
        ImageGenerator image;
        nRetVal = imageInfo.GetInstance(image);
        <a class="code" href="_xn_macros_8h.html#a6116e7b1f42e5ad6123f8fbb70b4bbca">XN_IS_STATUS_OK</a>(nRetVal);

        DepthGenerator depth;
        nRetVal = depthInfo.GetInstance(depth);
        <a class="code" href="_xn_macros_8h.html#a6116e7b1f42e5ad6123f8fbb70b4bbca">XN_IS_STATUS_OK</a>(nRetVal);

        *ppInstance = <span class="keyword">new</span> MyHandsGenerator(image, depth);
        <span class="keywordflow">if</span> (*ppInstance == NULL)
        {
            <span class="keywordflow">return</span> XN_STATUS_ALLOC_FAILED;
        }

        <span class="keywordflow">return</span> <a class="code" href="_xn_status_8h.html#a92729089d8e28e740a3f8b5169c8f695">XN_STATUS_OK</a>;
    }

    <span class="keyword">virtual</span> <span class="keywordtype">void</span> Destroy(ModuleProductionNode* pInstance) 
    {
        <span class="keyword">delete</span> pInstance;
    }
};
</pre></div> </div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Wed Jun 13 21:55:35 2012 for OpenNI 1.5.4 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
