<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>OpenNI 1.5.4: xn::Generator Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespacexn.html">xn</a>::<a class="el" href="classxn_1_1_generator.html">Generator</a>
  </div>
</div>
<div class="contents">
<h1>xn::Generator Class Reference<br/>
<small>
[<a class="el" href="group__cppref__prd__func.html">Production Nodes Functionality</a>]</small>
</h1><!-- doxytag: class="xn::Generator" --><!-- doxytag: inherits="xn::ProductionNode" -->
<p><code>#include &lt;<a class="el" href="_xn_cpp_wrapper_8h_source.html">XnCppWrapper.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for xn::Generator:</div>
<div class="dynsection">
<div class="center"><img src="classxn_1_1_generator__inherit__graph.png" border="0" usemap="#xn_1_1_generator_inherit__map" alt="Inheritance graph"/></div>
<map name="xn_1_1_generator_inherit__map" id="xn_1_1_generator_inherit__map">
<area shape="rect" href="classxn_1_1_audio_generator.html" title="xn::AudioGenerator" alt="" coords="519,5,652,35"/><area shape="rect" href="classxn_1_1_gesture_generator.html" title="xn::GestureGenerator" alt="" coords="512,59,659,88"/><area shape="rect" href="classxn_1_1_hands_generator.html" title="xn::HandsGenerator" alt="" coords="517,112,653,141"/><area shape="rect" href="classxn_1_1_map_generator.html" title="xn::MapGenerator" alt="" coords="523,165,648,195"/><area shape="rect" href="classxn_1_1_mock_raw_generator.html" title="xn::MockRawGenerator" alt="" coords="507,219,664,248"/><area shape="rect" href="classxn_1_1_user_generator.html" title="xn::UserGenerator" alt="" coords="521,272,649,301"/><area shape="rect" href="classxn_1_1_production_node.html" title="xn::ProductionNode" alt="" coords="173,139,309,168"/><area shape="rect" href="classxn_1_1_node_wrapper.html" title="xn::NodeWrapper" alt="" coords="5,139,125,168"/><area shape="rect" href="classxn_1_1_mock_audio_generator.html" title="xn::MockAudioGenerator" alt="" coords="712,5,877,35"/><area shape="rect" href="classxn_1_1_depth_generator.html" title="xn::DepthGenerator" alt="" coords="728,85,861,115"/><area shape="rect" href="classxn_1_1_image_generator.html" title="xn::ImageGenerator" alt="" coords="727,139,863,168"/><area shape="rect" href="classxn_1_1_i_r_generator.html" title="xn::IRGenerator" alt="" coords="739,192,851,221"/><area shape="rect" href="classxn_1_1_scene_analyzer.html" title="xn::SceneAnalyzer" alt="" coords="729,245,860,275"/><area shape="rect" href="classxn_1_1_mock_depth_generator.html" title="xn::MockDepthGenerator" alt="" coords="927,85,1092,115"/><area shape="rect" href="classxn_1_1_mock_image_generator.html" title="xn::MockImageGenerator" alt="" coords="925,139,1093,168"/><area shape="rect" href="classxn_1_1_mock_i_r_generator.html" title="xn::MockIRGenerator" alt="" coords="937,192,1081,221"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="classxn_1_1_generator-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_generator.html#a23866c5ad6a10efc2070acbb00470874">Generator</a> (<a class="el" href="_xn_types_8h.html#aec321f7c8a5939f5e4079e64999010f6">XnNodeHandle</a> hNode=NULL)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_generator.html#a9f24a82e98e1421aab4eb71f244f7c37">Generator</a> (const <a class="el" href="classxn_1_1_node_wrapper.html">NodeWrapper</a> &amp;other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_generator.html#a4fa8a933a96765b30537b5203da3381e">StartGenerating</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">XnBool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_generator.html#a5b1f69de8cfac0767729a4584778d7cf">IsGenerating</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_generator.html#ae955127df36f3c71e76bdc5f2e383065">StopGenerating</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_generator.html#a5fc2c00997d7e827ce1e86d7b89ec2f1">RegisterToGenerationRunningChange</a> (<a class="el" href="group__cppref__glb__ev__hndlrs.html#ga5fedcd8960bde65dea449adbbd3d040d">StateChangedHandler</a> handler, void *pCookie, <a class="el" href="_xn_types_8h.html#a5d00277c28def4d18f1605d5198ad77d">XnCallbackHandle</a> &amp;hCallback)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_generator.html#a4ef03272d55e2146ae2b0f17db317d38">UnregisterFromGenerationRunningChange</a> (<a class="el" href="_xn_types_8h.html#a5d00277c28def4d18f1605d5198ad77d">XnCallbackHandle</a> hCallback)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_generator.html#a8fcad557eda5746a7f974e51c70bb324">RegisterToNewDataAvailable</a> (<a class="el" href="group__cppref__glb__ev__hndlrs.html#ga5fedcd8960bde65dea449adbbd3d040d">StateChangedHandler</a> handler, void *pCookie, <a class="el" href="_xn_types_8h.html#a5d00277c28def4d18f1605d5198ad77d">XnCallbackHandle</a> &amp;hCallback)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_generator.html#a9f9789cecbcc0e43ecf63817e21ac6da">UnregisterFromNewDataAvailable</a> (<a class="el" href="_xn_types_8h.html#a5d00277c28def4d18f1605d5198ad77d">XnCallbackHandle</a> hCallback)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">XnBool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_generator.html#ab1d6e18ad5169afec58dde1f3cf4f8bf">IsNewDataAvailable</a> (XnUInt64 *pnTimestamp=NULL) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_generator.html#aaf3162a87a79a05fa655f344c835fa2e">WaitAndUpdateData</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">XnBool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_generator.html#a46b2960e843339296201682c04c02b5d">IsDataNew</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_generator.html#a1dd4f7f779f636b7c984cda1edddff02">GetData</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">XnUInt32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_generator.html#a5b6c7e53de6b4d459f3e54ccfb81c31e">GetDataSize</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">XnUInt64&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_generator.html#a25ac36419b9761a70768cc59330330a2">GetTimestamp</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">XnUInt32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_generator.html#a5e819081604760a7690a11a20c53856a">GetFrameID</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classxn_1_1_mirror_capability.html">MirrorCapability</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_generator.html#a162ee01b3483dcf71075398e4a0bb948">GetMirrorCap</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxn_1_1_mirror_capability.html">MirrorCapability</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_generator.html#a67018dd9cc900520937547f747094576">GetMirrorCap</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <br class="typebreak"/>
<a class="el" href="classxn_1_1_alternative_view_point_capability.html">AlternativeViewPointCapability</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_generator.html#aa026cae7475aa794aad3cdfaa7d5c726">GetAlternativeViewPointCap</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxn_1_1_alternative_view_point_capability.html">AlternativeViewPointCapability</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_generator.html#ae99917e5a3c47578eadadea85ed5e4de">GetAlternativeViewPointCap</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classxn_1_1_frame_sync_capability.html">FrameSyncCapability</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_generator.html#ac78aa3433bef155939b0dc43f37e9e0d">GetFrameSyncCap</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxn_1_1_frame_sync_capability.html">FrameSyncCapability</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_generator.html#a2e4eee068a2a915288cb37788dd995a1">GetFrameSyncCap</a> ()</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p><b>Purpose:</b> A generator node produces some type of data. This is in addition to the node's basic characteristic, as a derivative of the <a class="el" href="classxn_1_1_production_node.html">xn::ProductionNode</a> class, i.e., that it represents a logical entity in the OpenNI <a class="el" href="prod__graph.html">Production</a> Graph".</p>
<p><b>Usage summary</b>: Immediate base class for all generator types. It itself is not usually instantiated.</p>
<p><b>Class Overview:</b></p>
<p>Each generator can be in Generating state or Non-Generating state. The application makes the node enter Generating state by calling the <a class="el" href="classxn_1_1_generator.html#a4fa8a933a96765b30537b5203da3381e">xn::Generator::StartGenerating()</a> method.</p>
<p>When a generator node is created, by default it is in Non-Generating state, so it does not generate data.</p>
<p>Generators have a default configuration (for example the FOV resolution) and an application can change the default configuration before actual data generation starts.</p>
<p>Once the application has completed configuring the generator node, the application can cause the node to start generating data.</p>
<p>Typically, the application will configure the generator only in the configuration stage, i.e., in Non-Generating state. The application can usually also configure the node while generating data, however configuration might then take longer and the application could also lose some frames of data. For example, if the application changes the resolution while in the Configuration stage (Non-Generating state), the resolution change occurs immediately; but if the application changes the configuration while the generator is generating data, the resolution change can take up to a few seconds to occur.</p>
<p><b>Data Storage:</b></p>
<p>Each call to an <a class="el" href="conc__updating__data.html">'Update Data'</a> method updates the generator node's application buffer, making the latest data available for applications to access. After a call to an <a class="el" href="conc__updating__data.html">'Update Data'</a> method, all subsequent calls to <a class="el" href="classxn_1_1_generator.html#a1dd4f7f779f636b7c984cda1edddff02">GetData()</a> will return exactly the same data until you call <a class="el" href="conc__updating__data.html">'Update Data'</a> again. The <a class="el" href="conc__updating__data.html">'Update Data'</a> method can be the generator node's own <a class="el" href="classxn_1_1_generator.html#aaf3162a87a79a05fa655f344c835fa2e">WaitAndUpdateData()</a> method or one of the Context's <a class="el" href="conc__updating__data.html">'WaitXUpdateAll'</a> methods.</p>
<p><b>Getting the Generated Data:</b></p>
<p><a class="el" href="classxn_1_1_generator.html">Generator</a> nodes will not output data to make it available for getting, until the application calls the node's <a class="el" href="classxn_1_1_generator.html#aaf3162a87a79a05fa655f344c835fa2e" title="Updates the generator node to the latest available data, first waiting for the node...">WaitAndUpdateData()</a> method (see below) or one of the context's <a class="el" href="conc__updating__data.html">'WaitXUpdateAll'</a> methods.</p>
<p><a class="el" href="conc__updating__data.html#conc_updating_data__sample_code_cmn">Sample Code</a> </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a23866c5ad6a10efc2070acbb00470874"></a><!-- doxytag: member="xn::Generator::Generator" ref="a23866c5ad6a10efc2070acbb00470874" args="(XnNodeHandle hNode=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xn::Generator::Generator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_xn_types_8h.html#aec321f7c8a5939f5e4079e64999010f6">XnNodeHandle</a>&nbsp;</td>
          <td class="paramname"> <em>hNode</em> = <code>NULL</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Ctor</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>hNode</em>&nbsp;</td><td>Node handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9f24a82e98e1421aab4eb71f244f7c37"></a><!-- doxytag: member="xn::Generator::Generator" ref="a9f24a82e98e1421aab4eb71f244f7c37" args="(const NodeWrapper &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xn::Generator::Generator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxn_1_1_node_wrapper.html">NodeWrapper</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ae99917e5a3c47578eadadea85ed5e4de"></a><!-- doxytag: member="xn::Generator::GetAlternativeViewPointCap" ref="ae99917e5a3c47578eadadea85ed5e4de" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxn_1_1_alternative_view_point_capability.html">AlternativeViewPointCapability</a> xn::Generator::GetAlternativeViewPointCap </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Gets an <a class="el" href="classxn_1_1_alternative_view_point_capability.html">AlternativeViewPointCapability</a> object for accessing Alternative Viewpoint functionality.</p>
<p><b>Remarks:</b></p>
<p>It is the application's responsibility to check first if <a class="el" href="_xn_types_8h.html#ad58a593043ae5041ff5a1962184527a8">XN_CAPABILITY_ALTERNATIVE_VIEW_POINT</a> is supported by calling <a class="el" href="classxn_1_1_production_node.html#a26574447d96527d1a9d79994e550037f">xn::Generator::IsCapabilitySupported()</a>. </p>

</div>
</div>
<a class="anchor" id="aa026cae7475aa794aad3cdfaa7d5c726"></a><!-- doxytag: member="xn::Generator::GetAlternativeViewPointCap" ref="aa026cae7475aa794aad3cdfaa7d5c726" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classxn_1_1_alternative_view_point_capability.html">AlternativeViewPointCapability</a> xn::Generator::GetAlternativeViewPointCap </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Gets an <a class="el" href="classxn_1_1_alternative_view_point_capability.html">AlternativeViewPointCapability</a> object for accessing Alternative Viewpoint functionality.</p>
<p><b>Remarks:</b></p>
<p>It is the application's responsibility to check first if <a class="el" href="_xn_types_8h.html#ad58a593043ae5041ff5a1962184527a8">XN_CAPABILITY_ALTERNATIVE_VIEW_POINT</a> is supported by calling <a class="el" href="classxn_1_1_production_node.html#a26574447d96527d1a9d79994e550037f">xn::Generator::IsCapabilitySupported()</a>. </p>

</div>
</div>
<a class="anchor" id="a1dd4f7f779f636b7c984cda1edddff02"></a><!-- doxytag: member="xn::Generator::GetData" ref="a1dd4f7f779f636b7c984cda1edddff02" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void* xn::Generator::GetData </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the <a class="el" href="glossary.html#frame_data">frame data</a> from the generator node. This is the latest data that the generator node has generated. </p>
<p><b>Remarks:</b></p>
<p>This method gets the data directly from the <a class="el" href="classxn_1_1_generator.html">Generator</a> node; not from the metadata object.</p>
<p>Compare this method with the Data() method of the <a class="el" href="classxn_1_1_output_meta_data.html">xn::OutputMetaData</a> object, where the latter gets the data from the metadata object. <a class="el" href="classxn_1_1_generator.html#a1dd4f7f779f636b7c984cda1edddff02" title="Gets the frame data from the generator node. This is the latest data that the generator...">GetData()</a> returns the same data as the GetMetaData().Data() method. However, using the <a class="el" href="classxn_1_1_generator.html#a1dd4f7f779f636b7c984cda1edddff02" title="Gets the frame data from the generator node. This is the latest data that the generator...">GetData()</a> method is slightly more costly.</p>
<p>The application usually should not use this method, but call each generator own data access methods, e.g. <a class="el" href="classxn_1_1_depth_generator.html#a595b24d346a23327a4effb695451b384">DepthGenerator::GetDepthMap()</a>. </p>

</div>
</div>
<a class="anchor" id="a5b6c7e53de6b4d459f3e54ccfb81c31e"></a><!-- doxytag: member="xn::Generator::GetDataSize" ref="a5b6c7e53de6b4d459f3e54ccfb81c31e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XnUInt32 xn::Generator::GetDataSize </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the data size of the <a class="el" href="glossary.html#frame_data">frame data</a>. This method gets the data size directly from the <a class="el" href="classxn_1_1_generator.html">Generator</a> node. </p>
<p><b>Remarks:</b></p>
<p>The size of the data is returned as a number of bytes.</p>
<p>Compare this method with the DataSize() method of the <a class="el" href="classxn_1_1_output_meta_data.html">xn::OutputMetaData</a> object, where the latter gets the data from the metadata object. <a class="el" href="classxn_1_1_generator.html#a5b6c7e53de6b4d459f3e54ccfb81c31e" title="Gets the data size of the frame data. This method gets the data size directly from...">GetDataSize()</a> returns the same data as the GetMetaData().DataSize() method. However, using the <a class="el" href="classxn_1_1_generator.html#a5b6c7e53de6b4d459f3e54ccfb81c31e" title="Gets the data size of the frame data. This method gets the data size directly from...">GetDataSize()</a> method is slightly more costly. </p>

</div>
</div>
<a class="anchor" id="a5e819081604760a7690a11a20c53856a"></a><!-- doxytag: member="xn::Generator::GetFrameID" ref="a5e819081604760a7690a11a20c53856a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XnUInt32 xn::Generator::GetFrameID </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the frame ID of the current frame data from the <a class="el" href="classxn_1_1_generator.html">Generator</a> node. </p>
<p><b>Remarks:</b></p>
<p>This method gets the frame ID directly from the <a class="el" href="classxn_1_1_generator.html">Generator</a> node.</p>
<p>Compare this method with the <b><a class="el" href="classxn_1_1_generator.html#a5e819081604760a7690a11a20c53856a" title="Gets the frame ID of the current frame data from the Generator node.">GetFrameID()</a></b> method of the <a class="el" href="classxn_1_1_output_meta_data.html">xn::OutputMetaData</a> object, where the latter gets the data from the metadata object. <b><a class="el" href="classxn_1_1_generator.html#a5e819081604760a7690a11a20c53856a" title="Gets the frame ID of the current frame data from the Generator node.">GetFrameID()</a></b> returns the same data as the GetMetaData().<a class="el" href="classxn_1_1_generator.html#a5e819081604760a7690a11a20c53856a" title="Gets the frame ID of the current frame data from the Generator node.">GetFrameID()</a> method. However, using the <b><a class="el" href="classxn_1_1_generator.html#a5e819081604760a7690a11a20c53856a" title="Gets the frame ID of the current frame data from the Generator node.">GetFrameID()</a></b> method is slightly more costly. </p>

</div>
</div>
<a class="anchor" id="a2e4eee068a2a915288cb37788dd995a1"></a><!-- doxytag: member="xn::Generator::GetFrameSyncCap" ref="a2e4eee068a2a915288cb37788dd995a1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxn_1_1_frame_sync_capability.html">FrameSyncCapability</a> xn::Generator::GetFrameSyncCap </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Gets an <a class="el" href="classxn_1_1_frame_sync_capability.html">FrameSyncCapability</a> object for accessing Frame Sync functionality.</p>
<p><b>Remarks:</b></p>
<p>It is the application's responsibility to check first if <a class="el" href="_xn_types_8h.html#af20bb6a3002393271448c336bad2b8b6">XN_CAPABILITY_FRAME_SYNC</a> is supported by calling <a class="el" href="classxn_1_1_production_node.html#a26574447d96527d1a9d79994e550037f">xn::Generator::IsCapabilitySupported()</a>. </p>

</div>
</div>
<a class="anchor" id="ac78aa3433bef155939b0dc43f37e9e0d"></a><!-- doxytag: member="xn::Generator::GetFrameSyncCap" ref="ac78aa3433bef155939b0dc43f37e9e0d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classxn_1_1_frame_sync_capability.html">FrameSyncCapability</a> xn::Generator::GetFrameSyncCap </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Gets an <a class="el" href="classxn_1_1_frame_sync_capability.html">FrameSyncCapability</a> object for accessing Frame Sync functionality.</p>
<p><b>Remarks:</b></p>
<p>It is the application's responsibility to check first if <a class="el" href="_xn_types_8h.html#af20bb6a3002393271448c336bad2b8b6">XN_CAPABILITY_FRAME_SYNC</a> is supported by calling <a class="el" href="classxn_1_1_production_node.html#a26574447d96527d1a9d79994e550037f">xn::Generator::IsCapabilitySupported()</a>. </p>

</div>
</div>
<a class="anchor" id="a67018dd9cc900520937547f747094576"></a><!-- doxytag: member="xn::Generator::GetMirrorCap" ref="a67018dd9cc900520937547f747094576" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxn_1_1_mirror_capability.html">MirrorCapability</a> xn::Generator::GetMirrorCap </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets a <a class="el" href="classxn_1_1_mirror_capability.html">MirrorCapability</a> object for accessing Mirror functionality. </p>
<p><b>Remarks:</b></p>
<p>It is the application's responsibility to check first if <a class="el" href="_xn_types_8h.html#a86a5cfe5a7b10ebff110ea7ec5c1fb5c">XN_CAPABILITY_MIRROR</a> is supported by calling <a class="el" href="classxn_1_1_production_node.html#a26574447d96527d1a9d79994e550037f">xn::ProductionNode::IsCapabilitySupported()</a>. </p>

</div>
</div>
<a class="anchor" id="a162ee01b3483dcf71075398e4a0bb948"></a><!-- doxytag: member="xn::Generator::GetMirrorCap" ref="a162ee01b3483dcf71075398e4a0bb948" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classxn_1_1_mirror_capability.html">MirrorCapability</a> xn::Generator::GetMirrorCap </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets a <a class="el" href="classxn_1_1_mirror_capability.html">MirrorCapability</a> object for accessing Mirror functionality. </p>
<p><b>Remarks:</b></p>
<p>It is the application's responsibility to check first if <a class="el" href="_xn_types_8h.html#a86a5cfe5a7b10ebff110ea7ec5c1fb5c">XN_CAPABILITY_MIRROR</a> is supported by calling <a class="el" href="classxn_1_1_production_node.html#a26574447d96527d1a9d79994e550037f">xn::ProductionNode::IsCapabilitySupported()</a>. </p>

</div>
</div>
<a class="anchor" id="a25ac36419b9761a70768cc59330330a2"></a><!-- doxytag: member="xn::Generator::GetTimestamp" ref="a25ac36419b9761a70768cc59330330a2" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XnUInt64 xn::Generator::GetTimestamp </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the frame timestamp from the <b><a class="el" href="classxn_1_1_generator.html">Generator</a></b> node This method gets the timestamp directly from the <a class="el" href="classxn_1_1_generator.html">Generator</a> node. </p>
<p><b>Remarks:</b></p>
<p>The time is returned in microseconds.</p>
<p>Compare this method with the <b><a class="el" href="classxn_1_1_generator.html#a25ac36419b9761a70768cc59330330a2" title="Gets the frame timestamp from the Generator node This method gets the timestamp directly...">GetTimestamp()</a></b> method of the <a class="el" href="classxn_1_1_output_meta_data.html">xn::OutputMetaData</a> object, where the latter gets the data from the metadata object. <b><a class="el" href="classxn_1_1_generator.html#a25ac36419b9761a70768cc59330330a2" title="Gets the frame timestamp from the Generator node This method gets the timestamp directly...">GetTimestamp()</a></b> returns the same data as the GetMetaData().<a class="el" href="classxn_1_1_generator.html#a25ac36419b9761a70768cc59330330a2" title="Gets the frame timestamp from the Generator node This method gets the timestamp directly...">GetTimestamp()</a> method. However, using the <b><a class="el" href="classxn_1_1_generator.html#a25ac36419b9761a70768cc59330330a2" title="Gets the frame timestamp from the Generator node This method gets the timestamp directly...">GetTimestamp()</a></b> method is slightly more costly. </p>

</div>
</div>
<a class="anchor" id="a46b2960e843339296201682c04c02b5d"></a><!-- doxytag: member="xn::Generator::IsDataNew" ref="a46b2960e843339296201682c04c02b5d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XnBool xn::Generator::IsDataNew </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns whether this node's frame data was updated by the most recent call to any <a class="el" href="conc__updating__data.html">'WaitXUpdateAll()'</a> function, e.g., <a class="el" href="classxn_1_1_context.html#a17fab043d7b6d60728511527a1d5c090">xn::Context::WaitAnyUpdateAll()</a>. </p>

</div>
</div>
<a class="anchor" id="a5b1f69de8cfac0767729a4584778d7cf"></a><!-- doxytag: member="xn::Generator::IsGenerating" ref="a5b1f69de8cfac0767729a4584778d7cf" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XnBool xn::Generator::IsGenerating </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns whether the node is currently in Generating state. </p>

</div>
</div>
<a class="anchor" id="ab1d6e18ad5169afec58dde1f3cf4f8bf"></a><!-- doxytag: member="xn::Generator::IsNewDataAvailable" ref="ab1d6e18ad5169afec58dde1f3cf4f8bf" args="(XnUInt64 *pnTimestamp=NULL) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XnBool xn::Generator::IsNewDataAvailable </td>
          <td>(</td>
          <td class="paramtype">XnUInt64 *&nbsp;</td>
          <td class="paramname"> <em>pnTimestamp</em> = <code>NULL</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns whether the node has new data available. The new data is available for updating, but can not yet be accessed by the application. The application needs to call <a class="el" href="conc__updating__data.html">'Update Data'</a> to gain access to that new data. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>pnTimestamp</em>&nbsp;</td><td>[Optional] If new data is available (TRUE is returned from the method), this param will hold the timestamp of that new data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5fc2c00997d7e827ce1e86d7b89ec2f1"></a><!-- doxytag: member="xn::Generator::RegisterToGenerationRunningChange" ref="a5fc2c00997d7e827ce1e86d7b89ec2f1" args="(StateChangedHandler handler, void *pCookie, XnCallbackHandle &amp;hCallback)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> xn::Generator::RegisterToGenerationRunningChange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cppref__glb__ev__hndlrs.html#ga5fedcd8960bde65dea449adbbd3d040d">StateChangedHandler</a>&nbsp;</td>
          <td class="paramname"> <em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pCookie</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_xn_types_8h.html#a5d00277c28def4d18f1605d5198ad77d">XnCallbackHandle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>hCallback</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Registers an event handler for the 'Generation State Change' event. </p>
<p>Registers a callback function to be called when generation starts or stops, i.e., when the generation state toggles between generating and not generating.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>handler</em>&nbsp;</td><td>Callback function to be invoked when the event is raised. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pCookie</em>&nbsp;</td><td>User's cookie, to be delivered to the callback. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>hCallback</em>&nbsp;</td><td>Handle to the callback to be used for unregistering it.</td></tr>
  </table>
  </dd>
</dl>
<p>For full details and usage of the parameters, see <a class="el" href="conc__events.html#reg_to_events">Registering to Events</a>. </p>

</div>
</div>
<a class="anchor" id="a8fcad557eda5746a7f974e51c70bb324"></a><!-- doxytag: member="xn::Generator::RegisterToNewDataAvailable" ref="a8fcad557eda5746a7f974e51c70bb324" args="(StateChangedHandler handler, void *pCookie, XnCallbackHandle &amp;hCallback)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> xn::Generator::RegisterToNewDataAvailable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cppref__glb__ev__hndlrs.html#ga5fedcd8960bde65dea449adbbd3d040d">StateChangedHandler</a>&nbsp;</td>
          <td class="paramname"> <em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pCookie</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_xn_types_8h.html#a5d00277c28def4d18f1605d5198ad77d">XnCallbackHandle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>hCallback</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Registers an event handler for the 'New Data Available' event. </p>
<p>The 'New Data Available' event is raised whenever a generator node has new data available. The new data is available for updating, but can not yet be accessed by the application. The application needs to call <a class="el" href="conc__updating__data.html">'Update Data'</a> to gain access to that new data.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>handler</em>&nbsp;</td><td>Callback function to be invoked when the event is raised. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pCookie</em>&nbsp;</td><td>User's cookie, to be delivered to the callback. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>hCallback</em>&nbsp;</td><td>Handle to the callback to be used for unregistering it.</td></tr>
  </table>
  </dd>
</dl>
<p>For full details and usage of the parameters, see <a class="el" href="conc__events.html#reg_to_events">Registering to Events</a>. </p>

</div>
</div>
<a class="anchor" id="a4fa8a933a96765b30537b5203da3381e"></a><!-- doxytag: member="xn::Generator::StartGenerating" ref="a4fa8a933a96765b30537b5203da3381e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> xn::Generator::StartGenerating </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enters the node into Generating state. </p>
<p>Enters the node into Generating state. In this state the node generates new frames.</p>
<p>After the application has called this method it can call an <a class="el" href="conc__updating__data.html">'Update Data'</a> method, e.g., <a class="el" href="classxn_1_1_generator.html#aaf3162a87a79a05fa655f344c835fa2e">xn::Generator::WaitAndUpdateData()</a>, to make a new frame available for getting. The application can then get the data (for example, using a metadata <a class="el" href="classxn_1_1_generator.html#a1dd4f7f779f636b7c984cda1edddff02" title="Gets the frame data from the generator node. This is the latest data that the generator...">GetData()</a> method, or some other mechanism depending on the type of node).</p>
<p><b>Remarks:</b></p>
<p>On entering the node into Generating state, OpenNI enters also all dependent nodes into Generating state. For example, if a <a class="el" href="classxn_1_1_user_generator.html">UserGenerator</a> node depends on data input from a <a class="el" href="classxn_1_1_depth_generator.html">DepthGenerator</a> node, and the <a class="el" href="classxn_1_1_user_generator.html">UserGenerator</a> node is entered into Generating state, then OpenNI will enter also the <a class="el" href="classxn_1_1_depth_generator.html">DepthGenerator</a> node into Generating state. </p>

</div>
</div>
<a class="anchor" id="ae955127df36f3c71e76bdc5f2e383065"></a><!-- doxytag: member="xn::Generator::StopGenerating" ref="ae955127df36f3c71e76bdc5f2e383065" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> xn::Generator::StopGenerating </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Makes the node leave Generating state (enters Non-Generating state). </p>
<p><b>Remarks:</b></p>
<p>If the node has metadata, after calling this method the data is still available as a saved <a class="el" href="glossary.html#glos_frame_object">frame object</a> in the metadata object. </p>

</div>
</div>
<a class="anchor" id="a4ef03272d55e2146ae2b0f17db317d38"></a><!-- doxytag: member="xn::Generator::UnregisterFromGenerationRunningChange" ref="a4ef03272d55e2146ae2b0f17db317d38" args="(XnCallbackHandle hCallback)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xn::Generator::UnregisterFromGenerationRunningChange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_xn_types_8h.html#a5d00277c28def4d18f1605d5198ad77d">XnCallbackHandle</a>&nbsp;</td>
          <td class="paramname"> <em>hCallback</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unregisters the 'Generation State Change' event handler. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>hCallback</em>&nbsp;</td><td>Handle received from registration.</td></tr>
  </table>
  </dd>
</dl>
<p>For full details and usage of the parameter, see <a class="el" href="conc__events.html#unreg_from_events">Unregistering from Events</a> . </p>

</div>
</div>
<a class="anchor" id="a9f9789cecbcc0e43ecf63817e21ac6da"></a><!-- doxytag: member="xn::Generator::UnregisterFromNewDataAvailable" ref="a9f9789cecbcc0e43ecf63817e21ac6da" args="(XnCallbackHandle hCallback)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xn::Generator::UnregisterFromNewDataAvailable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_xn_types_8h.html#a5d00277c28def4d18f1605d5198ad77d">XnCallbackHandle</a>&nbsp;</td>
          <td class="paramname"> <em>hCallback</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unregisters the event handler for the 'New Data Available' event. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>hCallback</em>&nbsp;</td><td>Handle received from registration.</td></tr>
  </table>
  </dd>
</dl>
<p>For full details and usage of the parameter, see <a class="el" href="conc__events.html#unreg_from_events">Unregistering from Events</a> . </p>

</div>
</div>
<a class="anchor" id="aaf3162a87a79a05fa655f344c835fa2e"></a><!-- doxytag: member="xn::Generator::WaitAndUpdateData" ref="aaf3162a87a79a05fa655f344c835fa2e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> xn::Generator::WaitAndUpdateData </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Updates the generator node to the latest available data, first waiting for the node to have new data available. </p>
<p><b>Remarks:</b></p>
<p>This method requests from OpenNI to cause the node to update its application buffers with new data, if it has new data available.</p>
<p>At this stage the generator node has "generated" new data. This method returns a success status. The application can now read the newly generated data.</p>
<p>An error situation is defined as: after a preset timeout, the node has not yet notified OpenNI it has new data available. On error, the method stops waiting and returns an error status.</p>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>XN_STATUS_INVALID_OPERATION</em>&nbsp;</td><td>This production node is not a generator. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>XN_STATUS_WAIT_DATA_TIMEOUT</em>&nbsp;</td><td>No new data available within 2 seconds. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_xn_cpp_wrapper_8h_source.html">XnCppWrapper.h</a></li>
</ul>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Wed Jun 13 21:55:49 2012 for OpenNI 1.5.4 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
