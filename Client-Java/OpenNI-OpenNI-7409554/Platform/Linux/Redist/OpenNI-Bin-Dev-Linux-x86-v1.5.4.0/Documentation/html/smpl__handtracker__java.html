<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>OpenNI 1.5.4: HandTracker.java - sample program (java)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="main.html">OpenNI Overview</a>&nbsp;&raquo;&nbsp;<a class="el" href="smpls__n__guides.html">Samples and Guides</a>&nbsp;&raquo;&nbsp;<a class="el" href="smpls.html">Sample Programs for the OpenNI API</a>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="smpl_handtracker_java">HandTracker.java - sample program (java) </a></h1><p><b>Source file:</b> Click the following link to view the source code file:</p>
<ul>
<li>HandTracker.java\HandTracker.java</li>
</ul>
<p>This section describes an OpenNI sample program for tracking a hand. This sample is encapsulated in the org.OpenNI.Samples.HandTracker.jar (java archive).</p>
<p>The documentation describes the sample program's code from the top of the program file(s) to bottom.</p>
<p>Every OpenNI feature is described the first time it appears in this sample program. Further appearances of the same feature are not described again.</p>
<h2><a class="anchor" id="hnd_trk_class_title">
HandTracker Class Title</a></h2>
<p>The whole program is defined inside the <code>HandTracker</code> Class.</p>
<h2><a class="anchor" id="htj_evhndlr_gestrec">
Handler for 'Gesture Recognized' Event</a></h2>
<p>The <a class="el" href="classxn_1_1_gesture_generator.html#aca37fc51dca69b7c697e588be879b9b9">'Gesture Recognized'</a> event signals that the <a class="el" href="classxn_1_1_gesture_generator.html">GestureGenerator</a> node has recognized the named gesture in the scene.</p>
<p>The following code block defines the event handler for the 'Gesture Recognized' event. </p>
<div class="fragment"><pre class="fragment">            <span class="keyword">class </span>MyGestureRecognized <span class="keyword">implements</span> IObserver&lt;GestureRecognizedEventArgs&gt;
            {
                ...
            }
</pre></div><p>The following is the main code in the body of the event handler.</p>
<p>The event handler calls the <a class="el" href="classxn_1_1_hands_generator.html#ac60c64231895f76465d795b3ca603778">StartTracking()</a> method of the <a class="el" href="classxn_1_1_hands_generator.html">HandsGenerator</a> node. This method causes the HandsGenerator node to start tracking at the specific position where the application expects a hand, which the application supplies as a parameter of the org.OpenNI.Point3D type. The parameter is <a class="el" href="_xn_types_8h.html#aa8d9d612c8b0b0075c90d8aea3d60164">getEndPosition()</a>, which is the position of the hand at the end of the gesture. </p>
<div class="fragment"><pre class="fragment">                handsGen.StartTracking(args.getEndPosition());
                gestureGen.removeGesture(<span class="stringliteral">&quot;Click&quot;</span>);
</pre></div><p>The getEndPosition() method gets the <code>pEndPosition</code> parameter from, the event handler, which is the position of the hand at the end of the gesture.</p>
<p>Now that the HandsGenerator is tracking a hand, the GestureGenerator does not have to look for the gesture anymore. So it does this by calling the <a class="el" href="classxn_1_1_gesture_generator.html#ac0874c99cf5da72e9eea84301719010e">RemoveGesture()</a> method to disable the GestureGenerator from looking for the named gesture in the FOV. </p>
<div class="fragment"><pre class="fragment">                gestureGen.removeGesture(<span class="stringliteral">&quot;Click&quot;</span>);
</pre></div><h2><a class="anchor" id="htj_evhndlr_handcrt">
Handler for 'Hand Create' Event</a></h2>
<p>Some implementations may want to use the <a class="el" href="classxn_1_1_hands_generator.html#af309aa3eb99956baefea29fddbe8ec09">'Hand Create'</a> event to signal that the <a class="el" href="classxn_1_1_hands_generator.html">HandsGenerator</a> node has recognized and started tracking a new hand in response to the application calling the xn::() method. This event returns the ID of the new hand, the time of its recognition, and its position on recognition in the current frame.</p>
<p>The following code block defines the event handler for the 'Hand Create' event. </p>
<div class="fragment"><pre class="fragment">            <span class="keyword">class </span>MyHandCreateEvent <span class="keyword">implements</span> IObserver&lt;ActiveHandEventArgs&gt;
            {
                ...
            }
</pre></div><p>The following is the main code in the body of the event handler.</p>
<p>The event handler calls a new list of <a class="el" href="_xn_types_8h.html#a200e09e2dc6145ac3c44151799c25014">org.OpenNI.Point3D</a> type structs. The <code>getPosition()</code> method returns the position at which the hand was created. </p>
<div class="fragment"><pre class="fragment">                ArrayList&lt;Point3D&gt; newList = <span class="keyword">new</span> ArrayList&lt;Point3D&gt;();
                newList.add(args.getPosition());
</pre></div><p>Now that the HandsGenerator is tracking the hand, it adds it to a history list created by this application. The history list is described later in <a class="el" href="smpl__handtracker__java.html#rec_raw_mainprg_dcl_blk_hist">declaration block</a>. </p>
<div class="fragment"><pre class="fragment">                history.put(<span class="keyword">new</span> Integer(args.getId()), newList);
</pre></div><h2><a class="anchor" id="htj_evhndlr_handupd">
Handler for 'Hand Update' Event</a></h2>
<p>The <a class="el" href="classxn_1_1_hands_generator.html#aa4985d7addc93a93e650592fff61d7f6">'Hand Update'</a> event signals that the <a class="el" href="classxn_1_1_hands_generator.html">HandsGenerator</a> node signals that a currently tracked hand was recognized at a specific position in the new frame. OpenNI continues to send this event at each further frame that the hand is still present. This event returns the ID of the hand, which is the same ID returned by the HandCreate event, the hand's new position, and the time of the update.</p>
<p>The following code block defines the event handler for the 'Hand Update' event. </p>
<div class="fragment"><pre class="fragment">            <span class="keyword">class </span>MyHandUpdateEvent <span class="keyword">implements</span> IObserver&lt;ActiveHandEventArgs&gt;
            {
                ...
            }
</pre></div><p>The following is the main code in the body of the event handler. The assignment in the first statement adds the new position of the hand to its own history buffer. The 'history' is a hash from an integer (the hand's unique, persistent ID) and a list of its last locations.</p>
<p>When adding a new location of the hand, we want to add them to the correct list. </p>
<div class="fragment"><pre class="fragment">            ArrayList&lt;Point3D&gt; historyList = history.get(args.getId());
            
            historyList.add(args.getPosition());
            
            <span class="keywordflow">while</span> (historyList.size() &gt; historySize)
            {
                historyList.remove(0);
            }
</pre></div><p>The above while loop provides a maximum history size, giving a 'moving tail' effect. This means that if there are too many points in the buffer, the oldest one is removed.</p>
<h2><a class="anchor" id="htj_evhndlr_handdestr">
Handler for 'Hand Destroy' Event</a></h2>
<p>The <a class="el" href="classxn_1_1_hands_generator.html#aa4985d7addc93a93e650592fff61d7f6">'Hand Destroy'</a> event signals that an existing hand has disappeared from the frame for any reason. This event returns the user ID &ndash; still the same user ID as before &ndash; and the time that it disappeared.</p>
<p>The following code block defines the event handler for the 'Hand Destroy' event. </p>
<div class="fragment"><pre class="fragment">            MyHandDestroyEvent implements IObserver&lt;InactiveHandEventArgs&gt;
            {
                ...
            }
</pre></div><p>The following code is the main code in the body of the event handler.</p>
<p>Now that the hand has been destroyed, in this example, the application wants to remove the user's ID from the history list. So the program gets the user's ID from the handler argument <code>args.getId</code>.</p>
<p>The code block below first removes the specific user's history buffer by calling <code>history.remove()</code>, and then we check if the general history is left empty, which means all hands were removed. The code then calls <code>history.isEmpty()</code> to check if the <code>history</code> listof hands has now become empty as a result of this hand having been destroyed. If it is empty, the program will then want to again start looking for the "Click" gesture. Thus, it then calls the <a class="el" href="classxn_1_1_gesture_generator.html#a0cdf45854e49ff2d4f3c5f24b75428d8">AddGesture()</a> method. </p>
<div class="fragment"><pre class="fragment">            history.remove(args.getId());
            <span class="keywordflow">if</span> (history.isEmpty())
            {
                <span class="keywordflow">try</span>
                {
                    gestureGen.addGesture(<span class="stringliteral">&quot;Click&quot;</span>);
                } <span class="keywordflow">catch</span> (StatusException e)
                {
                    e.printStackTrace();
                }
            }
</pre></div><h2><a class="anchor" id="htj_mainprg_dcl_blk">
Main Program Declaration Block: OpenNI Nodes</a></h2>
<p>The declaration block immediately above the main program (try) declares the OpenNI objects required for building the OpenNI production graph. The production graph is the main object model in OpenNI. </p>
<div class="fragment"><pre class="fragment">            <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keywordtype">long</span> serialVersionUID = 1L;
            <span class="keyword">private</span> OutArg&lt;ScriptNode&gt; scriptNode;
            <span class="keyword">private</span> Context context;
            <span class="keyword">private</span> DepthGenerator depthGen;
            <span class="keyword">private</span> GestureGenerator gestureGen;
            <span class="keyword">private</span> HandsGenerator handsGen;
</pre></div><p>Each of these concepts is described separately in the following paragraphs.</p>
<p>The <a class="el" href="prod__graph.html">production graph</a> is a network of software objects - called production nodes - that can identify blobs as hands or human users. In this sample program the production graph identifies blobs as human users, and tracks them as they move.</p>
<p>the <a class="el" href="classxn_1_1_script_node.html">ScriptNode</a> object loads an XML script from a file or string, and then runs the XML script to build a production graph.</p>
<p>a <a class="el" href="classxn_1_1_context.html">Context</a> object is a workspace in which the application builds an OpenNI production graph.</p>
<p>a <a class="el" href="classxn_1_1_depth_generator.html">DepthGenerator</a> node generates a depth map. Each map pixel value represents a distance from the sensor.</p>
<p>A <a class="el" href="classxn_1_1_gesture_generator.html">GestureGenerator</a> node recognizes certain hand gestures and raise corresponding events accordingly. A gesture is a specific hand movement. The GestureGenerator node scans the FOV to detect gestures and generates the gesture data.</p>
<p>A <a class="el" href="classxn_1_1_hands_generator.html">HandsGenerator</a> node generates tracking data about a single hand or multiple hands with persistent IDs.</p>
<h2><a class="anchor" id="rec_raw_mainprg_dcl_blk_hist">
Main Program Declaration Block: Application Histogram</a></h2>
<p>The following declaration block defines data structures for the application histogram. These are not OpenNI-specific declarations. </p>
<div class="fragment"><pre class="fragment">            <span class="keyword">private</span> HashMap&lt;Integer, ArrayList&lt;Point3D&gt;&gt; history;
            <span class="keyword">private</span> byte[] imgbytes;
            <span class="keyword">private</span> <span class="keywordtype">float</span> histogram[];

            <span class="keyword">private</span> BufferedImage bimg;
            <span class="keywordtype">int</span> width, height;
</pre></div><p> <code>history</code> is a history list of <a class="el" href="_xn_types_8h.html#a200e09e2dc6145ac3c44151799c25014">org.OpenNI.Point3D </a> objects, which are the 3D (x,y,z) co-ordinates of each depth pixel in the depth map generated by a DepthGenerator node.</p>
<p><code>histogram</code> is an array of floats to build a histogram of distribution of depth values. It will be used to represent different depth values with different colors..</p>
<p>The following declaration for <code>SAMPLE_XML_FILE</code> is the path to an OpenNI XML script file for inputting and building a stored production graph. private final String SAMPLE_XML_FILE = "../../../../Data/SamplesConfig.xml";</p>
<h2><a class="anchor" id="setup_pg">
HandTracker() method: Setting up the Production Graph</a></h2>
<p>The public HandTracker() routine sets up the Production Graph.</p>
<p>The following code initialization initializes the production graph from an OpenNI XML script file The call to <a class="el" href="classxn_1_1_context.html#aa0f2dff24c434ed56b44332456ea9502">Context.createFromXmlFile()</a> combines the effects of two other initialization methods &ndash; <a class="el" href="classxn_1_1_context.html#adfc68c424c840a788d0903e20a95e541">xn::Context::Init()</a> and then <a class="el" href="classxn_1_1_context.html#a0145a926d2656d0f05399ed8d5f90ec6">xn::Context::RunXmlScriptFromFile()</a> &ndash; to initialize the context object and then create a production graph. </p>
<div class="fragment"><pre class="fragment">            scriptNode = <span class="keyword">new</span> OutArg&lt;ScriptNode&gt;();
            context = Context.createFromXmlFile(SAMPLE_XML_FILE, scriptNode);
</pre></div><p>The following statements create and set up a GestureGenerator node. The addGesture() method activates the GestureGenerator node to start looking for the named gesture ("Click") in the FOV by adding the gesture's name to the node's list of gestures it actively scans for in the FOV. </p>
<div class="fragment"><pre class="fragment">            gestureGen = GestureGenerator.create(context);
            gestureGen.addGesture(<span class="stringliteral">&quot;Click&quot;</span>); {Not exactly the same as in the API}
</pre></div><p>The following statement sets up an event handler for the 'Gesture Recognized' event. The handler is the MyGestureRecognized() function declared elsewhere in the program sample. </p>
<div class="fragment"><pre class="fragment">            gestureGen.getGestureRecognizedEvent().addObserver(<span class="keyword">new</span> MyGestureRecognized() ); 
</pre></div><p>The following code block sets up event handlers for a number of hand recognition events. For details about these events, see <a href="#xncpp_wrpr_handgen_events">Hand Event Sequence Diagram</a>, and <a href="#xncpp_wrpr_handcreate_ev">'Hand Create'</a>, <a href="#xncpp_wrpr_handupdate_ev">'Hand Update'</a>, and <a href="#xncpp_wrpr_handdestroy_ev">'Hand Destroy'</a>. </p>
<div class="fragment"><pre class="fragment">            handsGen = HandsGenerator.create(context);
            handsGen.getHandCreateEvent().addObserver(<span class="keyword">new</span> MyHandCreateEvent());
            handsGen.getHandUpdateEvent().addObserver(<span class="keyword">new</span> MyHandUpdateEvent());
            handsGen.getHandDestroyEvent().addObserver(<span class="keyword">new</span> MyHandDestroyEvent());
</pre></div><p>The following statement creates a <a class="el" href="classxn_1_1_depth_generator.html">DepthGenerator</a>. </p>
<div class="fragment"><pre class="fragment">            depthGen = DepthGenerator.create(context);
</pre></div><p>In the following statement, the latest data generated is copied to an easy-to-access <a class="el" href="glossary.html#glos_frame_object">&lt;i&gt;frame object&lt;/i&gt;</a>. In OpenNI terminology: the node has data that is designated as 'metadata to be placed in the node's metadata object'. The node's getMetaData() method gets this data and copies it to a metadata object, <code>depthMD</code>. The data includes all configuration information associated with the data itself. This metadata object is then termed the <a class="el" href="glossary.html#glos_frame_object">&lt;i&gt;frame object&lt;/i&gt;</a>. <br/>
 For more explanation on this, see <a class="el" href="conc__meta__data.html">Frame Objects and Metadata Objects</a>, <a class="el" href="glossary.html#glos_frame_object">Frame Objects</a>, and <a class="el" href="glossary.html#frame_data">Frame Data (Data Frame)</a>. </p>
<div class="fragment"><pre class="fragment">            DepthMetaData depthMD = depthGen.getMetaData();
</pre></div><p>The following statement ensures all created <a class="el" href="glossary.html#dict_gen_node">generator nodes</a> are generating data. </p>
<div class="fragment"><pre class="fragment">            context.startGeneratingAll();
</pre></div><p>The following sets up the histogram (see <a class="el" href="smpl__handtracker__java.html#rec_raw_mainprg_dcl_blk_hist">Main Program Declaration Block: Application Histogram</a>). See <code>getFullXRes</code> and <code>getFullYRes</code> get the number of rows and columns in the full frame (that is, the entire field-of-view), ignoring cropping. This enables the program set up the right size buffer. </p>
<div class="fragment"><pre class="fragment">            history = <span class="keyword">new</span> HashMap&lt;Integer, ArrayList&lt;Point3D&gt;&gt;(); 

            histogram = <span class="keyword">new</span> <span class="keywordtype">float</span>[10000];
            width = depthMD.getFullXRes();
            height = depthMD.getFullYRes();

            imgbytes = <span class="keyword">new</span> byte[width*height];

            DataBufferByte dataBuffer = <span class="keyword">new</span> DataBufferByte(imgbytes, width*height);
            Raster raster = Raster.createPackedRaster(dataBuffer, width, height, 8, null);
            bimg = <span class="keyword">new</span> BufferedImage(width, height, BufferedImage.TYPE_BYTE_GRAY);
            bimg.setData(raster);
</pre></div><h2><a class="anchor" id="htj_calcHist">
CalcHist() - Using the Depth Values to Build an Accumulative Histogram</a></h2>
<p>There are no OpenNI-specific declarations in this routine.</p>
<h2><a class="anchor" id="htj_update_depth_fn">
updateDepth() method: Updating the Depth Map</a></h2>
<p>The following statement sets up the frame object. It is described in the <a href="#getMetaData">HandTracker() method above</a>. For more explanation on this, see <a class="el" href="conc__meta__data.html">Frame Objects and Metadata Objects</a>, <a class="el" href="glossary.html#glos_frame_object">Frame Objects</a>, and <a class="el" href="glossary.html#frame_data">Frame Data (Data Frame)</a>. </p>
<div class="fragment"><pre class="fragment">            DepthMetaData depthMD = depthGen.getMetaData();
</pre></div><p>The following method call waits for any node to have generated new data. This method then 'updates' each and every node in the entire production graph. For an overview to reading data and the <b>WaitXUpdateAll</b> methods, see <em><a class="el" href="conc__updating__data.html#conc_updating_data__summary_of_wait_fns">'Wait and Update' Methods</a></em>.</p>
<p>The <a class="el" href="classxn_1_1_context.html#a17fab043d7b6d60728511527a1d5c090">waitAnyUpdateAll()</a> method in the following statement waits for any node to have generated a new data frame. The method then makes the data frames of all nodes in the entire production graph available for getting. The application can then get the data (for example, using a metadata GetData() method). This method has a timeout. </p>
<div class="fragment"><pre class="fragment">            context.waitAnyUpdateAll();
</pre></div><p>The following code block creates a convenient buffer for the depth map and then calls the calcHist() method to calculate the histogram. There are no OpenNI-specific operations in this code block. </p>
<div class="fragment"><pre class="fragment">            ShortBuffer depth = depthMD.getData().createShortBuffer();
            calcHist(depth);
            depth.rewind();     
</pre></div><p>This code block copies the depth into a local buffer, so that it can be drawn on the screen. </p>
<div class="fragment"><pre class="fragment">            <span class="keywordflow">while</span>(depth.remaining() &gt; 0)
            {
                <span class="keywordtype">int</span> pos = depth.position();
                <span class="keywordtype">short</span> pixel = depth.get();
                imgbytes[pos] = (byte)histogram[pixel];
            }       
</pre></div><h2><a class="anchor" id="htj_getPreferredSize">
getPreferredSize() method</a></h2>
<p>There are no OpenNI-specific operations in this routine.</p>
<h2><a class="anchor" id="htj_paint">
paint() method</a></h2>
<p>This function draws the current location of each known hand, with a tail consisting of its previous points. It uses the history list populated in the HandGenerator callbacks. </p>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Wed Jun 13 21:55:36 2012 for OpenNI 1.5.4 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
