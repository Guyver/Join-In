<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>OpenNI 1.5.4: NiRecordSynthetic.cpp - sample program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="main.html">OpenNI Overview</a>&nbsp;&raquo;&nbsp;<a class="el" href="smpls__n__guides.html">Samples and Guides</a>&nbsp;&raquo;&nbsp;<a class="el" href="smpls.html">Sample Programs for the OpenNI API</a>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="smpl_record_syn">NiRecordSynthetic.cpp - sample program </a></h1><p><b>Source file:</b> Click the following link to view the source code file:</p>
<ul>
<li>NiRecordSynthetic.cpp</li>
</ul>
<p>This section describes an OpenNI sample program for generating and recording synthetic data.</p>
<p>The program opens a recording, performs a transformation on the data from the recording, and then re-records the transformed data.</p>
<p>The documentation describes the sample program's code from the top of the program file(s) to bottom.</p>
<p>Every OpenNI feature is described the first time it appears in this sample program. Further appearances of the same feature are not described again.</p>
<h2><a class="anchor" id="rec_syn_xform_depthmd">
transformDepthMD() function</a></h2>
<p>The following function provides the code for performing a transformation on the image data generated by the OpenNI <a class="el" href="prod__graph.html">nodes</a>. The function is described further below feature by feature. </p>
<div class="fragment"><pre class="fragment">            <span class="keywordtype">void</span> transformDepthMD(DepthMetaData&amp; depthMD)
            {
                <a class="code" href="group__cppref__meta__data.html#ga0e82c279a213d3de95505d5bb9c66e56">DepthMap</a>&amp; depthMap = depthMD.WritableDepthMap();
                <span class="keywordflow">for</span> (XnUInt32 y = 0; y &lt; depthMap.YRes(); y++)
                {
                    <span class="keywordflow">for</span> (XnUInt32 x = 0; x &lt; depthMap.XRes(); x++)
                    {
                        <span class="comment">//Punch vertical cut lines in the depth image</span>
                        <span class="keywordflow">if</span> ((x % 2) == 0)
                        {
                            depthMap(x, y) = 0;
                        }
                    }
                }
            }       
</pre></div><p>In the above, the <a class="el" href="classxn_1_1_depth_meta_data.html">DepthMetaData</a> object provides a <a class="el" href="glossary.html#glos_frame_object">frame object</a> for the <a class="el" href="classxn_1_1_depth_generator.html">xn::DepthGenerator</a> node. The <a class="el" href="glossary.html#glos_frame_object">frame object</a> of a <a class="el" href="glossary.html#dict_gen_node">generator node</a> contains a snapshot of generated data frame and all its associated properties. This data frame and its properties are accessible through the node's metadata object.</p>
<p><code>DepthMap</code> is a Map Wrapper class. The Map Wrapper classes are light wrappers for <a class="el" href="glossary.html#glos_frame_object">Frame Objects</a> maps.</p>
<p>The <a class="el" href="classxn_1_1_depth_meta_data.html#a0c7ae12342dc71f1bce62016048d64e8">WritableDepthMap()</a> method gets a light object to wrap the writable depth map. So this initializes the DepthMap map wrapper class. </p>
<div class="fragment"><pre class="fragment">            <a class="code" href="group__cppref__meta__data.html#ga0e82c279a213d3de95505d5bb9c66e56">DepthMap</a>&amp; depthMap = depthMD.WritableDepthMap();
</pre></div><p>The following double loop provides the x and y indexes to access each pixel in the <code>DepthMap</code>. The <a class="el" href="classxn_1_1_map.html#addae31672b376dc4a79d8856b831ab1b">XRes()</a> and <a class="el" href="classxn_1_1_map.html#a12df2e51951f42f4265e27e14d8d412b">YRes()</a> methods return the two dimensions of the data frame, width and height, respectively. </p>
<div class="fragment"><pre class="fragment">            <span class="keywordflow">for</span> (XnUInt32 y = 0; y &lt; depthMap.YRes(); y++)
            {
                <span class="keywordflow">for</span> (XnUInt32 x = 0; x &lt; depthMap.XRes(); x++)
                {
                 ...
                } 
            }
</pre></div><p>Here is the code that performs the data transformation. It punches vertical 'cut' lines in the depth image. </p>
<div class="fragment"><pre class="fragment">            <span class="keywordflow">if</span> ((x % 2) == 0)
            {
                depthMap(x, y) = 0;
            }       
</pre></div><h2><a class="anchor" id="rec_syn_mainprg">
main() â€“ Main Program</a></h2>
<h3><a class="anchor" id="rec_syn_mainprg_dcl_blk">
Main Program Declaration Block</a></h3>
<h3><a class="anchor" id="rec_syn_record">
Initializing the Log from an XML file</a></h3>
<p>In the following, the <a class="el" href="_xn_log_8h.html#a98c98054c03755c961d383e12b36b7dc">xn::xnLogInitFromXmlFile()</a> method function initializes the log from an XML file. It initializes only the log; not the context or production graph. </p>
<div class="fragment"><pre class="fragment">                nRetVal = nRetVal = <a class="code" href="_xn_log_8h.html#a98c98054c03755c961d383e12b36b7dc">xnLogInitFromXmlFile</a>(SAMPLE_XML_PATH);
                <span class="keywordflow">if</span> (nRetVal != <a class="code" href="_xn_status_8h.html#a92729089d8e28e740a3f8b5169c8f695">XN_STATUS_OK</a>)
                {
                    printf(<span class="stringliteral">&quot;Log couldn&#39;t be opened: %s. Running without log&quot;</span>, <a class="code" href="_xn_status_8h.html#a709a2190465f4a6d7893587e53d66798">xnGetStatusString</a>(nRetVal));
                }
</pre></div><h3><a class="anchor" id="rec_syn_getparams">
Creating and Setting up the Nodes</a></h3>
<p>The following initializes the <a class="el" href="classxn_1_1_context.html">xn::Context</a> object. This is where the application builds an OpenNI production graph. The <em>production graph</em> is a network of <em>production nodes</em> and is the principal OpenNI object structure. </p>
<div class="fragment"><pre class="fragment">                Context context;
                nRetVal = context.Init();
</pre></div><p>The <a class="el" href="classxn_1_1_context.html#a3589979f63d5b9ddea49b71dcdf9fc5a">OpenFileRecording()</a> method replays a recorded file of a session of OpenNI data generation exactly as it was recorded. This includes recreating the whole <a class="el" href="prod__graph.html">production graph</a>, with all its nodes, that was built to run the original data generation session. This method performs this replaying by also creating a 'mock node' for each node in the file, and populates it with the recorded configuration. For an example of a mock node, see <a class="el" href="classxn_1_1_mock_depth_generator.html">xn::MockDepthGenerator</a>. </p>
<div class="fragment"><pre class="fragment">                Player player;
                nRetVal = context.OpenFileRecording(strInputFile, player);
</pre></div><p>In the following code, the <a class="el" href="classxn_1_1_context.html#a48450b0fde8c947c8ba7683a4f882308">FindExistingNode()</a> method call gets a reference to a production node in the production graph. This sample program passes the <code>depth</code> parameter to get a reference to a <a class="el" href="classxn_1_1_depth_generator.html">DepthGenerator node</a> so that it can work with it. A <a class="el" href="classxn_1_1_depth_generator.html">xn::DepthGenerator</a> node generates a depth map. Each map pixel value represents a distance from the sensor. </p>
<div class="fragment"><pre class="fragment">            DepthGenerator depth;
            nRetVal = context.FindExistingNode(<a class="code" href="_xn_types_8h.html#ac773bbb9817dac5ae1be0f380ec18b52a1415a428ab99e92cebedd4fdb1fe74c6">XN_NODE_TYPE_DEPTH</a>, depth);
</pre></div><p>Create mock node based on depth node from recording The following declares a mock node. This is to simulate an actual node when recording or playing data from a recording. A mock node does not contain any logic for generating data. Instead, it allows an outside component (such as an application or a real node implementation) to feed it configuration changes and data. </p>
<div class="fragment"><pre class="fragment">                MockDepthGenerator mockDepth;
</pre></div><p>In the following statement, the <a class="el" href="classxn_1_1_mock_depth_generator.html">xn::MockDepthGenerator</a> node::CreateBasedOn() "CreateBasedOn()" method <em>creates</em> a "mock" <a class="el" href="classxn_1_1_depth_generator.html">DepthGenerator</a> node based on the type and properties of the base node, in this case the <code>depth</code> node. This node does not represent an actual node, but only keeps a state and implements an interface above it. Mock nodes are specifically used for simulating nodes for playing recordings, or for use in tests. </p>
<div class="fragment"><pre class="fragment">                nRetVal = mockDepth.CreateBasedOn(depth);
</pre></div><p>In the following, the call to <a class="el" href="classxn_1_1_recorder.html#a4d544321e6bcad40d68db50353a0d6ee">Create()</a> initalizes a Recorder object. This object records to a specified destination medium the frames of data from each node that was added to it. </p>
<div class="fragment"><pre class="fragment">                Recorder recorder;
                nRetVal = recorder.Create(context);
</pre></div><p>In the following statement, the call to <a class="el" href="classxn_1_1_recorder.html#a1e84f796966c9808b2a26db0d5dfe621">SetDestination()</a> specifies to where the recorder must send its recording. This is a disk file of ONI type. </p>
<div class="fragment"><pre class="fragment">                nRetVal = recorder.SetDestination(<a class="code" href="group__recorder.html#gga3a9ee4c35a7384ba06a4d22f976f8e8aab2fd201e9160a675b83ca2a3e4d36a0c">XN_RECORD_MEDIUM_FILE</a>, strOutputFile);
</pre></div><p>The following statement adds the node to the recording, and starts recording it. </p>
<div class="fragment"><pre class="fragment">                nRetVal = recorder.AddNodeToRecording(mockDepth);
</pre></div><p>The following statement specifies that the player will not automatically rewind to the beginning of the recording after reaching the end of the recording (the default behavior is to rewind). </p>
<div class="fragment"><pre class="fragment">                nRetVal = player.SetRepeat(<a class="code" href="_xn_platform_8h.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>);
</pre></div><p>The next code block gets the number of frames of a specific node played. In the case of this sample program this is just a statistic to print later on the console. </p>
<div class="fragment"><pre class="fragment">                XnUInt32 nNumFrames = 0;
                nRetVal = player.GetNumFrames(depth.GetName(), nNumFrames);
</pre></div><p>The following declares a metadata object for the DepthGenerator node. The metadata object is described above in the <a class="el" href="smpl__record__syn.html#rec_syn_xform_depthmd">transformDepthMD() function</a> transformDepthMD() function. </p>
<div class="fragment"><pre class="fragment">                DepthMetaData depthMD;
</pre></div><h3><a class="anchor" id="rec_syn_main_loop">
Main Program Loop</a></h3>
<p>Following is the main program loop. It waits for available data from the generator and prints it out. The call to the n::Generator::WaitAndUpdateData() "WaitAndUpdateData()" method updates the node's application buffer to the latest available data, first waiting for the node to have new data available. Since this method is being fed from a recording, the end of the recording is indicated by returning the XN_STATUS_EOF value.</p>
<p>Note that the <a class="el" href="classxn_1_1_generator.html#aaf3162a87a79a05fa655f344c835fa2e">WaitAndUpdateData()</a> method has to be called for each and every iteration to refresh the node's data. </p>
<div class="fragment"><pre class="fragment">                <span class="keywordflow">while</span> ((nRetVal = depth.WaitAndUpdateData()) != XN_STATUS_EOF)
                {
                    ...
                }
</pre></div><p>The statements of body of the main loop are presented and explained, in the following.</p>
<p>The following statement gets the DepthGenerator node's <a class="el" href="glossary.html#glos_frame_object">frame object</a> (the <a class="el" href="classxn_1_1_depth_meta_data.html">xn::DepthMetaData</a> frame object). The metadata object is described above in the <a class="el" href="smpl__record__syn.html#rec_syn_xform_depthmd">transformDepthMD() function</a> transformDepthMD() function. </p>
<div class="fragment"><pre class="fragment">                depth.GetMetaData(depthMD);
</pre></div><p>Enable the depth map to be modified. In the following statement, the call to the <a class="el" href="classxn_1_1_output_meta_data.html#a70d17b28fc0127d0ac10b6dc58942e97">MakeDataWritable()</a> allocates a buffer and copies current data to it, so that the data can be edited. </p>
<div class="fragment"><pre class="fragment">                nRetVal = depthMD.MakeDataWritable();
</pre></div><p>The following statement makes a call to the transformDepthMD(), already described above in <a class="el" href="smpl__record__syn.html#rec_syn_xform_depthmd">transformDepthMD() function</a>. This call transforms the data. </p>
<div class="fragment"><pre class="fragment">                transformDepthMD(depthMD);
</pre></div><p>The following statement passes the transformed data to the <a class="el" href="classxn_1_1_mock_depth_generator.html">xn::MockDepthGenerator</a> object. The call to the <a class="el" href="classxn_1_1_mock_depth_generator.html#a5e4b631fc5a3f5434a21582028888e12">SetData()</a> method sets the data of the mock node from a metadata object. </p>
<div class="fragment"><pre class="fragment">                nRetVal = mockDepth.SetData(depthMD);
</pre></div><p>The following statement records one frame of data from each node that was added to the recorder by the <a class="el" href="classxn_1_1_recorder.html#aa6023d6f933e831504c6ddaa8357927f">AddNodeToRecording()</a> method. To record continually, the Recorder node must be called repeatedly for each frame. </p>
<div class="fragment"><pre class="fragment">                nRetVal = Recorder.Record();
</pre></div><p>Finally, this sample program prints status information. In the statement below, the <a class="el" href="classxn_1_1_output_meta_data.html#a9f1b71bee803673f2330511a64bafe05">FrameID()</a> method gets the frame ID of <a class="el" href="glossary.html#glos_frame_object">frame object</a>. Frame IDs are a sequential unique number. </p>
<div class="fragment"><pre class="fragment">                printf(<span class="stringliteral">&quot;Recorded: frame %u out of %u\r&quot;</span>, depthMD.FrameID(), nNumFrames);
</pre></div> </div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Wed Jun 13 21:55:36 2012 for OpenNI 1.5.4 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
