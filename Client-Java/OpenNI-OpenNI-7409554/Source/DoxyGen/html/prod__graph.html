<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>OpenNI 1.5.4: The Production Graph</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="main.html">OpenNI Overview</a>&nbsp;&raquo;&nbsp;<a class="el" href="concepts.html">Concepts</a>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="prod_graph">The Production Graph </a></h1><p>The <em>production graph</em> is a network of <em>production nodes</em>. This is the principal OpenNI object model. The fundamental purpose and functionality of the production graph is to identify and track <em>blobs</em> as human hands or users.</p>
<p>A production graph is composed of a production node, and optionally a list of other production nodes needed for this production node. Each production node has a type (one of the types defined by the OpenNI specification), a vendor name, and a specific name (unique for this type and vendor), and a version. For example, a <a class="el" href="classxn_1_1_user_generator.html">UserGenerator</a> node may need a <a class="el" href="classxn_1_1_depth_generator.html">DepthGenerator</a> node, which in turn might need a <a class="el" href="classxn_1_1_device.html">Device </a> node.</p>
<h2><a class="anchor" id="enum_reg_mdls">
Enumerating the Registered Modules</a></h2>
<p>When OpenNI is initializing, it loads each registered module, and asks it for the types of nodes it implements. Then, when an application asks for a specific generated product, OpenNI enumerates every module that declared itself as generating that product, for currently possible production graphs. Each module builds a list of nodes it can create right now (possible by enumerating for other node types), and returns it to OpenNI. OpenNI then appends all those lists together, and returns them to the application. The application can then choose the specific node it wants to use right now, and asks OpenNI to create it.</p>
<h2><a class="anchor" id="crt_prd_nds">
Creating Production Nodes</a></h2>
<p>There are several ways to create production nodes:</p>
<ul>
<li>Using the <a class="el" href="classxn_1_1_context.html#a4e1316931421c0a36bd89ea6394c98ae">EnumerateProductionTrees()</a> method &ndash; choosing one result and calling CreateProductionTree() with this result</li>
<li>Using the <a class="el" href="classxn_1_1_context.html#a4dba9b1553322cfb4ecdff6b6c93a182">CreateAnyProductionTree()</a> method &ndash; shorthand for enumerating and choosing any result</li>
<li>Using XML files</li>
</ul>
<h2><a class="anchor" id="enum_to_crt_prd_nds">
Enumerating to Create Production Nodes</a></h2>
<p>The result from an enumeration operation is a pointer to the first node of a linked list, representing all the matching <a class="el" href="glossary.html#node_alternative">node alternatives</a>. Each <a class="el" href="glossary.html#node_alternative">node alternative</a> contains the provider description, an optional instance name (that can be used by the provider as proprietary information, like a device S/N), and a list of the node's dependencies (other needed nodes).</p>
<h2><a class="anchor" id="enuming_with_constraints">
Enumerating with Constraints</a></h2>
<p>When an application wants to create a production node, in most cases it will prefer (or even demand) certain constraints from those nodes. For example, an application might need the node to support a specific capability it needs. For this reason, the enumeration functions can take a <a class="el" href="classxn_1_1_query.html">Query</a> object as a parameter (see <a class="el" href="group__queries.html">Queries</a> for C, or <a class="el" href="classxn_1_1_query.html">xn::Query</a> for C++).</p>
<dl class="note"><dt><b>Note:</b></dt><dd>OpenNI can also return existing nodes during enumeration, if they match the requested criterias.</dd></dl>
<h2><a class="anchor" id="enuming_for_type">
Enumerating only for a Particular Type</a></h2>
<p>As a shortcut, in case the application doesn't care about different nodes, and just needs any node of the requested type, it can do so using one of the following functions:</p>
<ul>
<li><a class="el" href="group__depthgen.html#ga9f5e595a8fb9e9ba9e2d39887f1e1de1">xnCreateDepthGenerator()</a></li>
<li><a class="el" href="group__imagegen.html#ga7a6cc81c1bcfc378e5a1ba3d3b22e755">xnCreateImageGenerator()</a></li>
<li><a class="el" href="group__irgen.html#ga36bb4357b5ef8d0ed3cc659d5e69dae3">xnCreateIRGenerator()</a></li>
<li><a class="el" href="group__audio.html#gadefc8788c219eb2deb31a967e3f18fd3">xnCreateAudioGenerator()</a></li>
<li><a class="el" href="group__gestures.html#ga6d0b903e781c053e3ee28f094d30d646">xnCreateGestureGenerator()</a></li>
<li><a class="el" href="group__scene.html#gaa178b2f176db9ae0808259b280017574">xnCreateSceneAnalyzer()</a></li>
<li><a class="el" href="group__hands.html#ga48b78d4835ef56e9f5c9b1c3b673d70c">xnCreateHandsGenerator()</a></li>
<li><a class="el" href="group__user.html#ga9518de54e34bc236af03192d3f52e972">xnCreateUserGenerator()</a></li>
</ul>
<p>In C++ this can be done using</p>
<ul>
<li><a class="el" href="classxn_1_1_depth_generator.html#a7a20818a005e6a292d5adf82f8a8fc98">xn::DepthGenerator::Create()</a></li>
<li><a class="el" href="classxn_1_1_image_generator.html#a6c925e2cc848841a566eebb27275ef6b">xn::ImageGenerator::Create()</a></li>
<li><a class="el" href="classxn_1_1_i_r_generator.html#a07ec9aa03f783487742c2761745543e7">xn::IRGenerator::Create()</a></li>
<li><a class="el" href="classxn_1_1_audio_generator.html#a05bd2f2455e016c6f6fd2eefe5d548cf">xn::AudioGenerator::Create()</a></li>
<li><a class="el" href="classxn_1_1_gesture_generator.html#a6becdbc8d3fa2bf266fbf6efc446ff38">xn::GestureGenerator::Create()</a></li>
<li><a class="el" href="classxn_1_1_scene_analyzer.html#a3467d0624e61f84089a37948b1232ae0">xn::SceneAnalyzer::Create()</a></li>
<li><a class="el" href="classxn_1_1_hands_generator.html#a35406ad94eed27f3ff9b8744e5a29ac3">xn::HandsGenerator::Create()</a></li>
<li><a class="el" href="classxn_1_1_user_generator.html#a6178ad8d73b553df67e3da2b4a87aa53">xn::UserGenerator::Create()</a></li>
</ul>
<p>Note that just like in the full enumeration process, these functions also allow the application to specify certain constraints about the created nodes with a <a class="el" href="classxn_1_1_query.html">Query</a> object, such as the vendor that supplies the generator, a version number, certain capabilities, and more (see <a class="el" href="group__queries.html">Queries</a> for the C functions, or <a class="el" href="classxn_1_1_query.html">xn::Query</a> for the C++ functions).</p>
<h2><a class="anchor" id="nod_hndls">
Node Handles</a></h2>
<p>In the C interface, each production node in the context is accessed using a <a class="el" href="_xn_types_8h.html#aec321f7c8a5939f5e4079e64999010f6">node handle</a>.</p>
<p>Every function on a specific node takes the node handle as its first argument. In C++, every class inheriting from <a class="el" href="classxn_1_1_node_wrapper.html">xn::NodeWrapper</a> holds the handle as a member, making it easier for applications to use the methods.</p>
<h2><a class="anchor" id="bld_prod_graph">
Building the Production Graph</a></h2>
<p>An application usually needs just one 3D vision product to be generated by OpenNI (human pose, gestures recognition, etc.). However this generated product is usually produced using a production graph. This means the vision product can be generated in a number of ways - either by different algorithms or the same algorithm using different raw data for processing.</p>
<p>When an application asks OpenNI for a specific generated product, OpenNI returns a list of all currently possible ways of producing it. This depends on installed modules, currently attached devices, and available licenses.</p>
<p>A production graph is represented using an object called Node Info (see <a class="el" href="group__prdnodeinfo.html">Production Node Info</a> for C, or <a class="el" href="classxn_1_1_node_info.html">xn::NodeInfo</a> for C++). This object contains information about the current node, such as its vendor, name, version, and most importantly, its type. The node info object can represent either an existing node that was already created, or an option for creating a node. For example, if an application enumerates for a node in the first time with <a class="el" href="group__context.html#gadb271b9b16368e39429e4b496143eb18">xnEnumerateProductionTrees</a>, it will probably get a node info object which is not connected to an existing node. Once the application chooses to create this node with <a class="el" href="group__context.html#ga835f5aad1d1f7f098be320117a9124d0">xnCreateProductionTree</a>, a node will be created, and the node info object will also hold the node handle.</p>
<p>The application can choose a production graph according to some or all nodes in the graph. For example, suppose an application asks for a User Generator. A User Generator requires a Depth Generator to operate, and suppose there are two types of Depth Generators installed on the machine. In this case the application would get two production chains for the User Generator: One for each option of the underlying Depth Generator. The application can then choose the preferred production graph according to its considerations, e.g. choosing a specific vendor, or choosing a depth node that provides certain capabilities.</p>
<p>Each Node Info object holds a list of needed nodes, thus creating a nodes graph. The list of needed nodes is accessed using an object called Node Info List (see <a class="el" href="group__infolist.html">Production Node Info List</a> for C, or <a class="el" href="classxn_1_1_node_info_list.html">xn::NodeInfoList</a> for C++).</p>
<h3><a class="anchor" id="create_method">
Understanding the Create() method</a></h3>
<p><b>Purpose</b></p>
<p>The Create() method creates a production node from available production node alternatives of the same type. For example, if you call the Create() method of an ImageGenerator object, on successful execution the method returns a reference to an ImageGenerator node.</p>
<div class="fragment"><pre class="fragment">        <a class="code" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> Create (Context &amp;context, Query *pQuery=NULL, EnumerationErrors *pErrors=NULL)
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>Context</em>&nbsp;</td><td>Context in which to create the production node. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pQuery</em>&nbsp;</td><td>Optional. Filters the production node alternatives. </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>pErrors</em>&nbsp;</td><td>Optional. Returns information about production nodes that could not be created.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Remarks</b></p>
<p>In order to create any type of production node (e.g., a UserGenerator node) the application calls this method of the instantiated production object (e.g., a UserGenerator object). However, an appropriate OpenNI module (plug-in) must first be installed on the computer to provide that required type of production node (e.g., a UserGenerator node).</p>
<p>This method enumerates all available production node alternatives, taking into account any defined query. The method selects any one of the matching node alternatives it has found, in order to create the required type of production node.</p>
<p>By default, if an existing node matches the filter, the Create() method will return a reference to the existing node, and so it will not create a new node.</p>
<p>If no query is defined, this method uses any available node alternative to create the node. Thus in this case, no assumption can be made about which of the available production node alternatives the method will select to create the new node.</p>
<p>To fine control the selection the application can define an appropriate query to narrow down the number of production node alternatives for creating the required production node, so that only matching nodes will be considered for selection.</p>
<p>The Create() method is equivalent to calling EnumerateProductionTrees() followed by CreateProductionTree() on the first result. That is, to call CreateProductionTree() on the first production node alternative that EnumerateProductionTrees() returns.</p>
<p>On successful execution, the production object (e.g., the UserGenerator object) references the newly created production node (e.g., a UserGenerator node). The application can then use the other methods of the node.</p>
<p>The production node that is returned is always a complete production graph. That is to say, the returned node will bring with it all other dependant nodes it requires for generating its output data. For example, if the required production node is a UserGenerator node, and its dependencies include a DepthGenerator node, then the new UserGenerator node reference will also bring with it a reference to a DepthGenerator node, creating a new DepthGenerator node if necessary.</p>
<p>If the production node returned is the base of a production graph (e.g., a Device node), then it does not have any dependencies and so the node will not bring with it any associated nodes at all. In this case the length and breadth of the returned production graph will be just the single new node reference. </p>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Wed Jun 13 21:55:35 2012 for OpenNI 1.5.4 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
