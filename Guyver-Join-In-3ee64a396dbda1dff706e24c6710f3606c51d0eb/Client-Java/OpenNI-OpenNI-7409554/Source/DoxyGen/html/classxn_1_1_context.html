<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>OpenNI 1.5.4: xn::Context Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespacexn.html">xn</a>::<a class="el" href="classxn_1_1_context.html">Context</a>
  </div>
</div>
<div class="contents">
<h1>xn::Context Class Reference<br/>
<small>
[<a class="el" href="group__cppref__graph__mgmt.html">Managing the Production Graph</a>]</small>
</h1><!-- doxytag: class="xn::Context" -->
<p><code>#include &lt;<a class="el" href="_xn_cpp_wrapper_8h_source.html">XnCppWrapper.h</a>&gt;</code></p>

<p><a href="classxn_1_1_context-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>NodeCreationCookie</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>NodeDestructionCookie</b></td></tr>
<tr><td colspan="2"><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(XN_CALLBACK_TYPE *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#a138feec38f9d9c865b369a2093d4c9af">NodeCreationHandler</a> )(<a class="el" href="classxn_1_1_context.html">Context</a> &amp;context, <a class="el" href="classxn_1_1_production_node.html">ProductionNode</a> &amp;createdNode, void *pCookie)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(XN_CALLBACK_TYPE *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#a684270053551213f42897f192c441858">NodeDestructionHandler</a> )(<a class="el" href="classxn_1_1_context.html">Context</a> &amp;context, const XnChar *strDestroyedNodeName, void *pCookie)</td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#a390d0fda2853a789ae7f658d93f8ab5a">Context</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#a417f0e274f7aa6367d4b599bdf6b1dd0">Context</a> (<a class="el" href="_xn_types_8h.html#afe4a53c10750f7f95282a2b1568d3732">XnContext</a> *pContext)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#a933180756124766826051bf578bae896">Context</a> (const <a class="el" href="classxn_1_1_context.html">Context</a> &amp;other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#a245321d324cbba84bca29edf5c67fb0c">~Context</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxn_1_1_context.html">Context</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#a4868868cf4f55737001429d2190cecab">operator=</a> (const <a class="el" href="classxn_1_1_context.html">Context</a> &amp;other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_xn_types_8h.html#afe4a53c10750f7f95282a2b1568d3732">XnContext</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#a662df3272dccb2708fe672d1e87c04eb">GetUnderlyingObject</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">XnBool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#a69071bab71321a05774488342fd57a37">operator==</a> (const <a class="el" href="classxn_1_1_context.html">Context</a> &amp;other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">XnBool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#a6f3370558161336a8cde37b54f717597">operator!=</a> (const <a class="el" href="classxn_1_1_context.html">Context</a> &amp;other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#adfc68c424c840a788d0903e20a95e541">Init</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#a3cdce851bb38afd2555549c2120861ba">RunXmlScript</a> (const XnChar *strScript, <a class="el" href="classxn_1_1_script_node.html">ScriptNode</a> &amp;scriptNode, <a class="el" href="classxn_1_1_enumeration_errors.html">EnumerationErrors</a> *pErrors=NULL)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#a0145a926d2656d0f05399ed8d5f90ec6">RunXmlScriptFromFile</a> (const XnChar *strFileName, <a class="el" href="classxn_1_1_script_node.html">ScriptNode</a> &amp;scriptNode, <a class="el" href="classxn_1_1_enumeration_errors.html">EnumerationErrors</a> *pErrors=NULL)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#aa0f2dff24c434ed56b44332456ea9502">InitFromXmlFile</a> (const XnChar *strFileName, <a class="el" href="classxn_1_1_script_node.html">ScriptNode</a> &amp;scriptNode, <a class="el" href="classxn_1_1_enumeration_errors.html">EnumerationErrors</a> *pErrors=NULL)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#a3589979f63d5b9ddea49b71dcdf9fc5a">OpenFileRecording</a> (const XnChar *strFileName, <a class="el" href="classxn_1_1_production_node.html">ProductionNode</a> &amp;playerNode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#a8af6b8174f1cba7da685fefa1b29dc5c">CreateMockNode</a> (<a class="el" href="_xn_types_8h.html#ab786f8128488cec584d72c2642655e39">XnProductionNodeType</a> type, const XnChar *strName, <a class="el" href="classxn_1_1_production_node.html">ProductionNode</a> &amp;mockNode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#ad3d8f78cf331911c3b1568d7546ab6e0">CreateMockNodeBasedOn</a> (<a class="el" href="classxn_1_1_production_node.html">ProductionNode</a> &amp;originalNode, const XnChar *strName, <a class="el" href="classxn_1_1_production_node.html">ProductionNode</a> &amp;mockNode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#a29b01751eaad6978275ca7b86914aace">CreateCodec</a> (<a class="el" href="_xn_types_8h.html#a0c078fc21c85436c606efc6384eeb45f">XnCodecID</a> codecID, <a class="el" href="classxn_1_1_production_node.html">ProductionNode</a> &amp;initializerNode, <a class="el" href="classxn_1_1_codec.html">Codec</a> &amp;codec)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#a91783bb0e7e0ab38734a6bca5f229cf3">AddRef</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#a45b4f74d21dcca83a643e8566beb459d">Release</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#af06765d6feb2d6bb23deac208ee07a52">AddLicense</a> (const <a class="el" href="struct_xn_license.html">XnLicense</a> &amp;License)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#a814139db1cc65308f4e019afae8d9e48">EnumerateLicenses</a> (<a class="el" href="struct_xn_license.html">XnLicense</a> *&amp;aLicenses, XnUInt32 &amp;nCount) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#a4e1316931421c0a36bd89ea6394c98ae">EnumerateProductionTrees</a> (<a class="el" href="_xn_types_8h.html#ab786f8128488cec584d72c2642655e39">XnProductionNodeType</a> Type, const <a class="el" href="classxn_1_1_query.html">Query</a> *pQuery, <a class="el" href="classxn_1_1_node_info_list.html">NodeInfoList</a> &amp;TreesList, <a class="el" href="classxn_1_1_enumeration_errors.html">EnumerationErrors</a> *pErrors=NULL) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#a4dba9b1553322cfb4ecdff6b6c93a182">CreateAnyProductionTree</a> (<a class="el" href="_xn_types_8h.html#ab786f8128488cec584d72c2642655e39">XnProductionNodeType</a> type, <a class="el" href="classxn_1_1_query.html">Query</a> *pQuery, <a class="el" href="classxn_1_1_production_node.html">ProductionNode</a> &amp;node, <a class="el" href="classxn_1_1_enumeration_errors.html">EnumerationErrors</a> *pErrors=NULL)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#adaa8daba096969ff9f16b7e8cb35cf93">CreateProductionTree</a> (<a class="el" href="classxn_1_1_node_info.html">NodeInfo</a> &amp;Tree, <a class="el" href="classxn_1_1_production_node.html">ProductionNode</a> &amp;node)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#ac62acceb4c705d53380a56b85d0c8137">EnumerateExistingNodes</a> (<a class="el" href="classxn_1_1_node_info_list.html">NodeInfoList</a> &amp;list) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#a3a236e6192b9783580e9b9008b3d0579">EnumerateExistingNodes</a> (<a class="el" href="classxn_1_1_node_info_list.html">NodeInfoList</a> &amp;list, <a class="el" href="_xn_types_8h.html#ab786f8128488cec584d72c2642655e39">XnProductionNodeType</a> type) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#a48450b0fde8c947c8ba7683a4f882308">FindExistingNode</a> (<a class="el" href="_xn_types_8h.html#ab786f8128488cec584d72c2642655e39">XnProductionNodeType</a> type, <a class="el" href="classxn_1_1_production_node.html">ProductionNode</a> &amp;node) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#a984f596b5ac26934fd9459c756f82167">GetProductionNodeByName</a> (const XnChar *strInstanceName, <a class="el" href="classxn_1_1_production_node.html">ProductionNode</a> &amp;node) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#a5e815f85fe4a2e8c15be8566444d57ba">GetProductionNodeInfoByName</a> (const XnChar *strInstanceName, <a class="el" href="classxn_1_1_node_info.html">NodeInfo</a> &amp;nodeInfo) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#affa5173b7c32b98d344ab2c8634f2cb7">StartGeneratingAll</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#aecf4d38b0cc4b50a376a83c4761670b5">StopGeneratingAll</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#adcdabaa87787c0e3b61e37619c6a6590">SetGlobalMirror</a> (XnBool bMirror)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">XnBool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#a585e4474303bb536ecdee5b1743cd8e7">GetGlobalMirror</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#a9694adb05ee44e1d9a4407f7053672d8">GetGlobalErrorState</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#a3cdfff9d6af00fc66c67223409af7f33">RegisterToErrorStateChange</a> (<a class="el" href="_xn_types_8h.html#abf283d8cc6f616cc7e12bf2d084bfea7">XnErrorStateChangedHandler</a> handler, void *pCookie, <a class="el" href="_xn_types_8h.html#a5d00277c28def4d18f1605d5198ad77d">XnCallbackHandle</a> &amp;hCallback)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#a45df3c90dc12709c777ef1b531bab8b3">UnregisterFromErrorStateChange</a> (<a class="el" href="_xn_types_8h.html#a5d00277c28def4d18f1605d5198ad77d">XnCallbackHandle</a> hCallback)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#abf6a81364fd5bbf1b22123936961bef4">RegisterToNodeCreation</a> (<a class="el" href="classxn_1_1_context.html#a138feec38f9d9c865b369a2093d4c9af">NodeCreationHandler</a> handler, void *pCookie, <a class="el" href="_xn_types_8h.html#a5d00277c28def4d18f1605d5198ad77d">XnCallbackHandle</a> &amp;hCallback)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#a2714f66a8247705422a56621574671d0">UnregisterFromNodeCreation</a> (<a class="el" href="_xn_types_8h.html#a5d00277c28def4d18f1605d5198ad77d">XnCallbackHandle</a> hCallback)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#accd23341f93552deca937733a6b82ab2">RegisterToNodeDestruction</a> (<a class="el" href="classxn_1_1_context.html#a684270053551213f42897f192c441858">NodeDestructionHandler</a> handler, void *pCookie, <a class="el" href="_xn_types_8h.html#a5d00277c28def4d18f1605d5198ad77d">XnCallbackHandle</a> &amp;hCallback)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#aa85fb69ce08a373a9a6fdd25d697dd4f">UnregisterFromNodeDestruction</a> (<a class="el" href="_xn_types_8h.html#a5d00277c28def4d18f1605d5198ad77d">XnCallbackHandle</a> hCallback)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#a52929d2a535166b18098e066900f9d59">WaitAndUpdateAll</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#a17fab043d7b6d60728511527a1d5c090">WaitAnyUpdateAll</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#ad4bab84f35a855639d485da99a05c585">WaitOneUpdateAll</a> (<a class="el" href="classxn_1_1_production_node.html">ProductionNode</a> &amp;node)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#ae498b727aa0fdade75f91bdb2563f88c">WaitNoneUpdateAll</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#adbac4aa85e6f9b0820925cc5e6d763bd">AutoEnumerateOverSingleInput</a> (<a class="el" href="classxn_1_1_node_info_list.html">NodeInfoList</a> &amp;List, <a class="el" href="struct_xn_production_node_description.html">XnProductionNodeDescription</a> &amp;description, const XnChar *strCreationInfo, <a class="el" href="_xn_types_8h.html#ab786f8128488cec584d72c2642655e39">XnProductionNodeType</a> InputType, <a class="el" href="classxn_1_1_enumeration_errors.html">EnumerationErrors</a> *pErrors, <a class="el" href="classxn_1_1_query.html">Query</a> *pQuery=NULL) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#ae9b3626c96bda6f9423de567061b05ae">SetHandle</a> (<a class="el" href="_xn_types_8h.html#afe4a53c10750f7f95282a2b1568d3732">XnContext</a> *pContext)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#accbc2a151989fe58879aa1f0bef81e85">TakeOwnership</a> (<a class="el" href="_xn_types_8h.html#afe4a53c10750f7f95282a2b1568d3732">XnContext</a> *pContext)</td></tr>
<tr><td colspan="2"><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxn_1_1_context.html#ad5aba10f694d2eab283598c9e1f1ee3b">FreeLicensesList</a> (<a class="el" href="struct_xn_license.html">XnLicense</a> aLicenses[])</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>A context is a workspace where the application builds an OpenNI production graph. It contains methods for managing the production graph.</p>
<p>In order to use any of the OpenNI functionality you must first construct a <a class="el" href="classxn_1_1_context.html">Context</a> object and initialize it. Prior to this, the application cannot do anything with OpenNI.</p>
<p>For a comprehensive overview to the <a class="el" href="classxn_1_1_context.html">Context</a> class and its members, see <a class="el" href="conc__context.html">Overview to Contexts</a>.</p>
<h2><a class="anchor" id="context_global_error_event">
Event: 'Global Error State Change'</a></h2>
<p>Signals that the error state of any of the nodes has changed.</p>
<p>This event can be used by the application to get a signal as soon as any error occurs in one of the production nodes. The global error state aggregates error state from all the production nodes in the context.</p>
<p>Use <a class="el" href="classxn_1_1_context.html#a3cdfff9d6af00fc66c67223409af7f33">RegisterToErrorStateChange()</a> and <a class="el" href="classxn_1_1_context.html#a45df3c90dc12709c777ef1b531bab8b3">UnregisterFromErrorStateChange()</a> for using this event.</p>
<h2><a class="anchor" id="context_node_creation_event">
Event: 'Node Creation'</a></h2>
<p>Signals that a new node was created in the context production graph.</p>
<p>Use <a class="el" href="classxn_1_1_context.html#abf6a81364fd5bbf1b22123936961bef4">RegisterToNodeCreation()</a> and <a class="el" href="classxn_1_1_context.html#a2714f66a8247705422a56621574671d0">UnregisterFromNodeCreation()</a> for using this event.</p>
<h2><a class="anchor" id="context_node_destruction_event">
Event: 'Node Destruction'</a></h2>
<p>Signals that a node was removed from the context production graph, and destroyed.</p>
<p>Use <a class="el" href="classxn_1_1_context.html#accd23341f93552deca937733a6b82ab2">RegisterToNodeDestruction()</a> and <a class="el" href="classxn_1_1_context.html#aa85fb69ce08a373a9a6fdd25d697dd4f">UnregisterFromNodeDestruction()</a> for using this event. </p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a138feec38f9d9c865b369a2093d4c9af"></a><!-- doxytag: member="xn::Context::NodeCreationHandler" ref="a138feec38f9d9c865b369a2093d4c9af" args=")(Context &amp;context, ProductionNode &amp;createdNode, void *pCookie)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(XN_CALLBACK_TYPE* <a class="el" href="classxn_1_1_context.html#a138feec38f9d9c865b369a2093d4c9af">xn::Context::NodeCreationHandler</a>)(<a class="el" href="classxn_1_1_context.html">Context</a> &amp;context, <a class="el" href="classxn_1_1_production_node.html">ProductionNode</a> &amp;createdNode, void *pCookie)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Callback prototype for the <a class="el" href="classxn_1_1_context.html#context_node_creation_event">'Node Creation'</a> event handler.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>context</em>&nbsp;</td><td>The context that raised this event. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>createdNode</em>&nbsp;</td><td>The id of the hand that disappeared. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pCookie</em>&nbsp;</td><td>A user-provided cookie that was given when registering to this event.</td></tr>
  </table>
  </dd>
</dl>
<p>Example for such a handler: </p>
<div class="fragment"><pre class="fragment">         <span class="keywordtype">void</span> XN_CALLBACK_TYPE OnNodeCreation(<a class="code" href="classxn_1_1_context.html#a390d0fda2853a789ae7f658d93f8ab5a">Context</a>&amp; context, ProductionNode&amp; createdNode, <span class="keywordtype">void</span>* pCookie)
         {}
</pre></div> 
</div>
</div>
<a class="anchor" id="a684270053551213f42897f192c441858"></a><!-- doxytag: member="xn::Context::NodeDestructionHandler" ref="a684270053551213f42897f192c441858" args=")(Context &amp;context, const XnChar *strDestroyedNodeName, void *pCookie)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(XN_CALLBACK_TYPE* <a class="el" href="classxn_1_1_context.html#a684270053551213f42897f192c441858">xn::Context::NodeDestructionHandler</a>)(<a class="el" href="classxn_1_1_context.html">Context</a> &amp;context, const XnChar *strDestroyedNodeName, void *pCookie)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Callback prototype for the <a class="el" href="classxn_1_1_context.html#context_node_destruction_event">'Node Destruction'</a> event handler.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>context</em>&nbsp;</td><td>The context that raised this event. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>strDestroyedNodeName</em>&nbsp;</td><td>The name of the node that was destroyed. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pCookie</em>&nbsp;</td><td>A user-provided cookie that was given when registering to this event.</td></tr>
  </table>
  </dd>
</dl>
<p>Example for such a handler: </p>
<div class="fragment"><pre class="fragment">         <span class="keywordtype">void</span> XN_CALLBACK_TYPE OnNodeDestruction(<a class="code" href="classxn_1_1_context.html#a390d0fda2853a789ae7f658d93f8ab5a">Context</a>&amp; context, <span class="keyword">const</span> XnChar* strDestroyedNodeName, <span class="keywordtype">void</span>* pCookie)
         {}
</pre></div> 
</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a390d0fda2853a789ae7f658d93f8ab5a"></a><!-- doxytag: member="xn::Context::Context" ref="a390d0fda2853a789ae7f658d93f8ab5a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xn::Context::Context </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Ctor </p>

</div>
</div>
<a class="anchor" id="a417f0e274f7aa6367d4b599bdf6b1dd0"></a><!-- doxytag: member="xn::Context::Context" ref="a417f0e274f7aa6367d4b599bdf6b1dd0" args="(XnContext *pContext)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xn::Context::Context </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_xn_types_8h.html#afe4a53c10750f7f95282a2b1568d3732">XnContext</a> *&nbsp;</td>
          <td class="paramname"> <em>pContext</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Ctor</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pContext</em>&nbsp;</td><td>Underlying C object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a933180756124766826051bf578bae896"></a><!-- doxytag: member="xn::Context::Context" ref="a933180756124766826051bf578bae896" args="(const Context &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xn::Context::Context </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxn_1_1_context.html">Context</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Copy Ctor</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>other</em>&nbsp;</td><td>Another context. Note that the context will only be destroyed when the original object is destroyed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a245321d324cbba84bca29edf5c67fb0c"></a><!-- doxytag: member="xn::Context::~Context" ref="a245321d324cbba84bca29edf5c67fb0c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xn::Context::~Context </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Dtor </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="af06765d6feb2d6bb23deac208ee07a52"></a><!-- doxytag: member="xn::Context::AddLicense" ref="af06765d6feb2d6bb23deac208ee07a52" args="(const XnLicense &amp;License)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> xn::Context::AddLicense </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xn_license.html">XnLicense</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>License</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p> For full details and usage, see <a class="el" href="group__lic.html#gabe1f7682dce8f5171f43f6eab7e30f41">xnAddLicense</a> </p>

</div>
</div>
<a class="anchor" id="a91783bb0e7e0ab38734a6bca5f229cf3"></a><!-- doxytag: member="xn::Context::AddRef" ref="a91783bb0e7e0ab38734a6bca5f229cf3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> xn::Context::AddRef </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Adds a reference to the context object.  For full details and usage, see <a class="el" href="group__context.html#ga598906a4be124df2f5b4a7c089b0598e">xnContextAddRef</a> </p>

</div>
</div>
<a class="anchor" id="adbac4aa85e6f9b0820925cc5e6d763bd"></a><!-- doxytag: member="xn::Context::AutoEnumerateOverSingleInput" ref="adbac4aa85e6f9b0820925cc5e6d763bd" args="(NodeInfoList &amp;List, XnProductionNodeDescription &amp;description, const XnChar *strCreationInfo, XnProductionNodeType InputType, EnumerationErrors *pErrors, Query *pQuery=NULL) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> xn::Context::AutoEnumerateOverSingleInput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxn_1_1_node_info_list.html">NodeInfoList</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>List</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xn_production_node_description.html">XnProductionNodeDescription</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>description</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XnChar *&nbsp;</td>
          <td class="paramname"> <em>strCreationInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_xn_types_8h.html#ab786f8128488cec584d72c2642655e39">XnProductionNodeType</a>&nbsp;</td>
          <td class="paramname"> <em>InputType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxn_1_1_enumeration_errors.html">EnumerationErrors</a> *&nbsp;</td>
          <td class="paramname"> <em>pErrors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxn_1_1_query.html">Query</a> *&nbsp;</td>
          <td class="paramname"> <em>pQuery</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p> For full details and usage, see <a class="el" href="group__utils.html#ga57d7bd49dda18e9bc37497f4a919463c">xnAutoEnumerateOverSingleInput</a> </p>

</div>
</div>
<a class="anchor" id="a4dba9b1553322cfb4ecdff6b6c93a182"></a><!-- doxytag: member="xn::Context::CreateAnyProductionTree" ref="a4dba9b1553322cfb4ecdff6b6c93a182" args="(XnProductionNodeType type, Query *pQuery, ProductionNode &amp;node, EnumerationErrors *pErrors=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> xn::Context::CreateAnyProductionTree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_xn_types_8h.html#ab786f8128488cec584d72c2642655e39">XnProductionNodeType</a>&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxn_1_1_query.html">Query</a> *&nbsp;</td>
          <td class="paramname"> <em>pQuery</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxn_1_1_production_node.html">ProductionNode</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxn_1_1_enumeration_errors.html">EnumerationErrors</a> *&nbsp;</td>
          <td class="paramname"> <em>pErrors</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enumerates for production nodes of a specific node type, and creates the first production node found of that type. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>type</em>&nbsp;</td><td>Requested node type. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pQuery</em>&nbsp;</td><td>Optional. A query object that can be used to filter results. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>node</em>&nbsp;</td><td>Handle to the newly created node. </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>pErrors</em>&nbsp;</td><td>Optional. To contain enumeration errors.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Remarks:</b></p>
<p>This method is a 'shortcut' version of using the <a class="el" href="classxn_1_1_context.html#a4e1316931421c0a36bd89ea6394c98ae">EnumerateProductionTrees()</a> method and then passing the first result to <a class="el" href="classxn_1_1_context.html#adaa8daba096969ff9f16b7e8cb35cf93">CreateProductionTree()</a>. Thus, this method is exactly like the <b>Create()</b> method for nodes.</p>
<p>Other ways of creating a production graph let the application retrieve a complete list of alternatives and then choose the most appropriate alternative.</p>
<p>This method is the method used by the above XML script methods to create the <a class="el" href="classxn_1_1_production_node.html">ProductionNode</a> objects. The XML method runs the XML script, and for each node description the XML method runs this function to create that node.</p>
<p>Using this function is called 'creating a node from the context'. You can also create a node by invoking the <b>Create</b> method of the node itself, e.g., the <a class="el" href="classxn_1_1_hands_generator.html#a35406ad94eed27f3ff9b8744e5a29ac3">Create()</a> method of a <a class="el" href="classxn_1_1_hands_generator.html">HandsGenerator</a> node.</p>
<p>By default, this method does not enable the production nodes to start generating data immediately on creation.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="prod__graph.html#create_method">Understanding the Create() method</a> for more detail. </dd></dl>

</div>
</div>
<a class="anchor" id="a29b01751eaad6978275ca7b86914aace"></a><!-- doxytag: member="xn::Context::CreateCodec" ref="a29b01751eaad6978275ca7b86914aace" args="(XnCodecID codecID, ProductionNode &amp;initializerNode, Codec &amp;codec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> xn::Context::CreateCodec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_xn_types_8h.html#a0c078fc21c85436c606efc6384eeb45f">XnCodecID</a>&nbsp;</td>
          <td class="paramname"> <em>codecID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxn_1_1_production_node.html">ProductionNode</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>initializerNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxn_1_1_codec.html">Codec</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>codec</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p> For full details and usage, see <a class="el" href="group__codec.html#ga4b1c9d8aa1a4c8b9f683aa1b2f612fd1">xnCreateCodec</a> </p>

</div>
</div>
<a class="anchor" id="a8af6b8174f1cba7da685fefa1b29dc5c"></a><!-- doxytag: member="xn::Context::CreateMockNode" ref="a8af6b8174f1cba7da685fefa1b29dc5c" args="(XnProductionNodeType type, const XnChar *strName, ProductionNode &amp;mockNode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> xn::Context::CreateMockNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_xn_types_8h.html#ab786f8128488cec584d72c2642655e39">XnProductionNodeType</a>&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XnChar *&nbsp;</td>
          <td class="paramname"> <em>strName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxn_1_1_production_node.html">ProductionNode</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>mockNode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a production node which is only a mock. This node does not represent an actual node, but only keeps a state and implements an interface above it. Mock nodes are useful when simulating nodes for playing recordings, or for use in tests. See also <a class="el" href="group__context.html#ga1cab33ab4c7da00726a25398e3a1d05a">xnCreateMockNodeBasedOn()</a>.  For full details and usage, see <a class="el" href="group__context.html#ga543daf92a09af0840d771baea0862df7">xnCreateMockNode</a> </p>

</div>
</div>
<a class="anchor" id="ad3d8f78cf331911c3b1568d7546ab6e0"></a><!-- doxytag: member="xn::Context::CreateMockNodeBasedOn" ref="ad3d8f78cf331911c3b1568d7546ab6e0" args="(ProductionNode &amp;originalNode, const XnChar *strName, ProductionNode &amp;mockNode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> xn::Context::CreateMockNodeBasedOn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxn_1_1_production_node.html">ProductionNode</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>originalNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XnChar *&nbsp;</td>
          <td class="paramname"> <em>strName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxn_1_1_production_node.html">ProductionNode</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>mockNode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a production node which is only a mock, base on the type and properties of another node. This node does not represent an actual node, but only keeps a state and implements an interface above it. Mock nodes are useful when simulating nodes for playing recordings, or for use in tests. See also <a class="el" href="group__context.html#ga543daf92a09af0840d771baea0862df7">xnCreateMockNode()</a>.  For full details and usage, see <a class="el" href="group__context.html#ga1cab33ab4c7da00726a25398e3a1d05a">xnCreateMockNodeBasedOn</a> </p>

</div>
</div>
<a class="anchor" id="adaa8daba096969ff9f16b7e8cb35cf93"></a><!-- doxytag: member="xn::Context::CreateProductionTree" ref="adaa8daba096969ff9f16b7e8cb35cf93" args="(NodeInfo &amp;Tree, ProductionNode &amp;node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> xn::Context::CreateProductionTree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxn_1_1_node_info.html">NodeInfo</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>Tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxn_1_1_production_node.html">ProductionNode</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>node</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a production node from the information supplied in a <a class="el" href="classxn_1_1_node_info.html">xn::NodeInfo</a> object. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>Tree</em>&nbsp;</td><td>Node properties for creating the new node. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>node</em>&nbsp;</td><td>Reference to the new <a class="el" href="classxn_1_1_production_node.html">xn::ProductionNode</a> object.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Remarks:</b></p>
<p>The application gets the <a class="el" href="classxn_1_1_node_info.html">NodeInfo</a> object by choosing it from the list returned by the <a class="el" href="classxn_1_1_context.html#a4e1316931421c0a36bd89ea6394c98ae">xn::Context::EnumerateProductionTrees()</a> method.</p>
<p>If the new production node requires additional nodes for its input, and those nodes do not yet exist, then this method creates those additional nodes also and associates them with the "original" new production node. </p>

</div>
</div>
<a class="anchor" id="a3a236e6192b9783580e9b9008b3d0579"></a><!-- doxytag: member="xn::Context::EnumerateExistingNodes" ref="a3a236e6192b9783580e9b9008b3d0579" args="(NodeInfoList &amp;list, XnProductionNodeType type) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> xn::Context::EnumerateExistingNodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxn_1_1_node_info_list.html">NodeInfoList</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_xn_types_8h.html#ab786f8128488cec584d72c2642655e39">XnProductionNodeType</a>&nbsp;</td>
          <td class="paramname"> <em>type</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a list of the context's existing created nodes filtered by type. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>list</em>&nbsp;</td><td>List of the context's existing created nodes. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>type</em>&nbsp;</td><td>Type to enumerate for.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Remarks</b></p>
<p>Returns the list after filtering them by type, so it returns a list of the created nodes of the specific type only.</p>
<p>An example of a typical case of returning a list of two nodes of the same type is where there are two sensors in a 3D set-up and you need to retrieve the corresponding two depth nodes to generate data from them.</p>
<p>You can use the <a class="el" href="classxn_1_1_node_info_list.html#aac62cedc1b2b3ce355539958988f4728">xn::NodeInfoList::FilterList()</a> method to filter the returned list of existing nodes. </p>

</div>
</div>
<a class="anchor" id="ac62acceb4c705d53380a56b85d0c8137"></a><!-- doxytag: member="xn::Context::EnumerateExistingNodes" ref="ac62acceb4c705d53380a56b85d0c8137" args="(NodeInfoList &amp;list) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> xn::Context::EnumerateExistingNodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxn_1_1_node_info_list.html">NodeInfoList</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>list</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a list of all the context's existing created nodes. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>list</em>&nbsp;</td><td>List of the context's existing created nodes.</td></tr>
  </table>
  </dd>
</dl>
<p>You can use the <a class="el" href="classxn_1_1_node_info_list.html#aac62cedc1b2b3ce355539958988f4728">xn::NodeInfoList::FilterList()</a> method to filter the returned list of existing nodes. </p>

</div>
</div>
<a class="anchor" id="a814139db1cc65308f4e019afae8d9e48"></a><!-- doxytag: member="xn::Context::EnumerateLicenses" ref="a814139db1cc65308f4e019afae8d9e48" args="(XnLicense *&amp;aLicenses, XnUInt32 &amp;nCount) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> xn::Context::EnumerateLicenses </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xn_license.html">XnLicense</a> *&amp;&nbsp;</td>
          <td class="paramname"> <em>aLicenses</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XnUInt32 &amp;&nbsp;</td>
          <td class="paramname"> <em>nCount</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p> For full details and usage, see <a class="el" href="group__lic.html#gaa1753b7044eb05c1640b9f47c05d33c1">xnEnumerateLicenses</a> </p>

</div>
</div>
<a class="anchor" id="a4e1316931421c0a36bd89ea6394c98ae"></a><!-- doxytag: member="xn::Context::EnumerateProductionTrees" ref="a4e1316931421c0a36bd89ea6394c98ae" args="(XnProductionNodeType Type, const Query *pQuery, NodeInfoList &amp;TreesList, EnumerationErrors *pErrors=NULL) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> xn::Context::EnumerateProductionTrees </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_xn_types_8h.html#ab786f8128488cec584d72c2642655e39">XnProductionNodeType</a>&nbsp;</td>
          <td class="paramname"> <em>Type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxn_1_1_query.html">Query</a> *&nbsp;</td>
          <td class="paramname"> <em>pQuery</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxn_1_1_node_info_list.html">NodeInfoList</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>TreesList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxn_1_1_enumeration_errors.html">EnumerationErrors</a> *&nbsp;</td>
          <td class="paramname"> <em>pErrors</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enumerates all available production nodes for a specific node type (e.g., the application wants to create a depth generator node) and returns a full list of matching production nodes. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>Type</em>&nbsp;</td><td>Requested node type. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pQuery</em>&nbsp;</td><td>Optional. A query object that can be used to filter results. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>TreesList</em>&nbsp;</td><td>List of possible production nodes. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>pErrors</em>&nbsp;</td><td>Optional. To contain enumeration errors.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Remarks:</b></p>
<p>The application chooses one of the nodes from the node list returned by this method and uses it as input to the <a class="el" href="classxn_1_1_context.html#adaa8daba096969ff9f16b7e8cb35cf93">xn::Context::CreateProductionTree()</a> method to create a new production node.</p>
<p>Using this method to help create a production node offers the greatest flexibility since it returns a complete list of matching production nodes and so the application can then choose the most suitable node.</p>
<p>By contrast, using <a class="el" href="classxn_1_1_context.html#a4dba9b1553322cfb4ecdff6b6c93a182">CreateAnyProductionTree()</a> or a node's <b>Create()</b> method creates a node from the first matching node that satisfies the query. </p>

</div>
</div>
<a class="anchor" id="a48450b0fde8c947c8ba7683a4f882308"></a><!-- doxytag: member="xn::Context::FindExistingNode" ref="a48450b0fde8c947c8ba7683a4f882308" args="(XnProductionNodeType type, ProductionNode &amp;node) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> xn::Context::FindExistingNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_xn_types_8h.html#ab786f8128488cec584d72c2642655e39">XnProductionNodeType</a>&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxn_1_1_production_node.html">ProductionNode</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>node</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Searches for an existing created node of a specified type and returns a reference to it. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>type</em>&nbsp;</td><td>Type of node to search for. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>node</em>&nbsp;</td><td>Reference to an existing created node that was found.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Remarks</b></p>
<p>This method returns only the first node it finds; this method does not return the entire list of matching nodes. Compare this with the <a class="el" href="classxn_1_1_context.html#ac62acceb4c705d53380a56b85d0c8137">xn::Context::EnumerateExistingNodes()</a> method, which returns the entire list of matching nodes. A typical usage is that the application already created all the nodes from XML. Then, when it needs to start generating data from a particular node, e.g., the skeleton data, it will call FindExistingNode specifying the skeleton type, and it will get it and start using it.</p>
<p>This method does not provide a query parameter (compare with <a class="el" href="classxn_1_1_context.html#ac62acceb4c705d53380a56b85d0c8137">xn::Context::EnumerateExistingNodes</a>). </p>

</div>
</div>
<a class="anchor" id="ad5aba10f694d2eab283598c9e1f1ee3b"></a><!-- doxytag: member="xn::Context::FreeLicensesList" ref="ad5aba10f694d2eab283598c9e1f1ee3b" args="(XnLicense aLicenses[])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void xn::Context::FreeLicensesList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xn_license.html">XnLicense</a>&nbsp;</td>
          <td class="paramname"> <em>aLicenses</em>[]</td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p> For full details and usage, see <a class="el" href="group__lic.html#ga504810407ef9b73ab42d34db1228d125">xnFreeLicensesList</a> </p>

</div>
</div>
<a class="anchor" id="a9694adb05ee44e1d9a4407f7053672d8"></a><!-- doxytag: member="xn::Context::GetGlobalErrorState" ref="a9694adb05ee44e1d9a4407f7053672d8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> xn::Context::GetGlobalErrorState </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Gets the global error state of the context. If one of the nodes in the context is in error state, that state will be returned. If more than one node is in error state, XN_STATUS_MULTIPLE_NODES_ERROR is returned. An application can query each node error state by calling <a class="el" href="group__err__state.html#ga8d8ea67a479a6a138b6c39b6d4f86049">xnGetNodeErrorState()</a>.  For full details and usage, see <a class="el" href="group__context.html#gad71392e3e7bb8a07fa791162a248aece">xnGetGlobalErrorState</a> </p>

</div>
</div>
<a class="anchor" id="a585e4474303bb536ecdee5b1743cd8e7"></a><!-- doxytag: member="xn::Context::GetGlobalMirror" ref="a585e4474303bb536ecdee5b1743cd8e7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XnBool xn::Context::GetGlobalMirror </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the current state of the GlobalMirror flag. </p>

</div>
</div>
<a class="anchor" id="a984f596b5ac26934fd9459c756f82167"></a><!-- doxytag: member="xn::Context::GetProductionNodeByName" ref="a984f596b5ac26934fd9459c756f82167" args="(const XnChar *strInstanceName, ProductionNode &amp;node) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> xn::Context::GetProductionNodeByName </td>
          <td>(</td>
          <td class="paramtype">const XnChar *&nbsp;</td>
          <td class="paramname"> <em>strInstanceName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxn_1_1_production_node.html">ProductionNode</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>node</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p> For full details and usage, see <a class="el" href="group__context.html#ga354130d1c691d598a97c325340d715df">xnGetNodeHandleByName</a> </p>

</div>
</div>
<a class="anchor" id="a5e815f85fe4a2e8c15be8566444d57ba"></a><!-- doxytag: member="xn::Context::GetProductionNodeInfoByName" ref="a5e815f85fe4a2e8c15be8566444d57ba" args="(const XnChar *strInstanceName, NodeInfo &amp;nodeInfo) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> xn::Context::GetProductionNodeInfoByName </td>
          <td>(</td>
          <td class="paramtype">const XnChar *&nbsp;</td>
          <td class="paramname"> <em>strInstanceName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxn_1_1_node_info.html">NodeInfo</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>nodeInfo</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p> For full details and usage, see <a class="el" href="group__context.html#ga354130d1c691d598a97c325340d715df">xnGetNodeHandleByName</a> </p>

</div>
</div>
<a class="anchor" id="a662df3272dccb2708fe672d1e87c04eb"></a><!-- doxytag: member="xn::Context::GetUnderlyingObject" ref="a662df3272dccb2708fe672d1e87c04eb" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_xn_types_8h.html#afe4a53c10750f7f95282a2b1568d3732">XnContext</a>* xn::Context::GetUnderlyingObject </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Gets the underlying C object </p>

</div>
</div>
<a class="anchor" id="adfc68c424c840a788d0903e20a95e541"></a><!-- doxytag: member="xn::Context::Init" ref="adfc68c424c840a788d0903e20a95e541" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> xn::Context::Init </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds the context's general software environment. </p>
<p>This method initializes runtime variables and data structures, and examines all registered plug-ins to learn the purpose and specific capabilities of each. In particular, during initialization the context initialization examines all registered plug-ins to learn the purpose and specific capabilities of each. For example, one plug-in is for creating a skeleton node, and another plug-in is for creating a depth node. Thus an entire database is built of plug-ins that can be queried according to vendor, model, and capabilities of each.</p>
<p>Once you have completed the initialization you can create nodes that are based on the plug-ins that OpenNI has discovered by this initialization process. </p>

</div>
</div>
<a class="anchor" id="aa0f2dff24c434ed56b44332456ea9502"></a><!-- doxytag: member="xn::Context::InitFromXmlFile" ref="aa0f2dff24c434ed56b44332456ea9502" args="(const XnChar *strFileName, ScriptNode &amp;scriptNode, EnumerationErrors *pErrors=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> xn::Context::InitFromXmlFile </td>
          <td>(</td>
          <td class="paramtype">const XnChar *&nbsp;</td>
          <td class="paramname"> <em>strFileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxn_1_1_script_node.html">ScriptNode</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>scriptNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxn_1_1_enumeration_errors.html">EnumerationErrors</a> *&nbsp;</td>
          <td class="paramname"> <em>pErrors</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Shorthand combination of two other initialization methods - <a class="el" href="classxn_1_1_context.html#adfc68c424c840a788d0903e20a95e541">Init()</a> and then <a class="el" href="classxn_1_1_context.html#a0145a926d2656d0f05399ed8d5f90ec6">RunXmlScriptFromFile()</a> - to initialize the context object and then create a production graph. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>strFileName</em>&nbsp;</td><td>Name of file containing an XML script. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>scriptNode</em>&nbsp;</td><td><a class="el" href="classxn_1_1_script_node.html">ScriptNode</a> object as the root to all the nodes created from the XML file. When no longer needed, the node can be released, causing all the created nodes to decrement their reference counts. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>pErrors</em>&nbsp;</td><td>Optional. To be filled with enumeration errors.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Remarks:</b></p>
<p>The XML script file describes all the nodes you want to create. For each node description in the XML file, this method creates a <a class="el" href="classxn_1_1_production_node.html">xn::ProductionNode</a> object. </p>

</div>
</div>
<a class="anchor" id="a3589979f63d5b9ddea49b71dcdf9fc5a"></a><!-- doxytag: member="xn::Context::OpenFileRecording" ref="a3589979f63d5b9ddea49b71dcdf9fc5a" args="(const XnChar *strFileName, ProductionNode &amp;playerNode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> xn::Context::OpenFileRecording </td>
          <td>(</td>
          <td class="paramtype">const XnChar *&nbsp;</td>
          <td class="paramname"> <em>strFileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxn_1_1_production_node.html">ProductionNode</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>playerNode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Recreates a production graph from a recorded ONI file and then replays the data generation exactly as it was recorded. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>strFileName</em>&nbsp;</td><td>Name of the recorded file to be run. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>playerNode</em>&nbsp;</td><td>Returns a <a class="el" href="classxn_1_1_player.html">xn::Player</a> object through which playback can be controlled, e.g., seeking and setting playback speed.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Remarks:</b></p>
<p>OpenNI provides great flexibility of recording. You can decide you want to record only the final output, e.g., just a skeleton in movement; or record both the output skeleton and the depth input; or record only the depth input and then recreate the skeleton at run-time after reading the recorded raw depth data. You can also choose which nodes to record. </p>

</div>
</div>
<a class="anchor" id="a6f3370558161336a8cde37b54f717597"></a><!-- doxytag: member="xn::Context::operator!=" ref="a6f3370558161336a8cde37b54f717597" args="(const Context &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XnBool xn::Context::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxn_1_1_context.html">Context</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Checks if two context objects are <em>not</em> references to the same context.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>other</em>&nbsp;</td><td>Another object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4868868cf4f55737001429d2190cecab"></a><!-- doxytag: member="xn::Context::operator=" ref="a4868868cf4f55737001429d2190cecab" args="(const Context &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxn_1_1_context.html">Context</a>&amp; xn::Context::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxn_1_1_context.html">Context</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a69071bab71321a05774488342fd57a37"></a><!-- doxytag: member="xn::Context::operator==" ref="a69071bab71321a05774488342fd57a37" args="(const Context &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XnBool xn::Context::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxn_1_1_context.html">Context</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Checks if two context objects are references to the same context.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>other</em>&nbsp;</td><td>Another object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3cdfff9d6af00fc66c67223409af7f33"></a><!-- doxytag: member="xn::Context::RegisterToErrorStateChange" ref="a3cdfff9d6af00fc66c67223409af7f33" args="(XnErrorStateChangedHandler handler, void *pCookie, XnCallbackHandle &amp;hCallback)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> xn::Context::RegisterToErrorStateChange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_xn_types_8h.html#abf283d8cc6f616cc7e12bf2d084bfea7">XnErrorStateChangedHandler</a>&nbsp;</td>
          <td class="paramname"> <em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pCookie</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_xn_types_8h.html#a5d00277c28def4d18f1605d5198ad77d">XnCallbackHandle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>hCallback</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Registers an event handler for the 'Global Error State Change' event. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>handler</em>&nbsp;</td><td>Callback function to be invoked when the event is raised. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pCookie</em>&nbsp;</td><td>User's cookie, to be delivered to the callback. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>hCallback</em>&nbsp;</td><td>Handle to the callback to be used for unregistering it.</td></tr>
  </table>
  </dd>
</dl>
<p>For full details and usage of the parameters, see <a class="el" href="conc__events.html#reg_to_events">Registering to Events</a>. </p>

</div>
</div>
<a class="anchor" id="abf6a81364fd5bbf1b22123936961bef4"></a><!-- doxytag: member="xn::Context::RegisterToNodeCreation" ref="abf6a81364fd5bbf1b22123936961bef4" args="(NodeCreationHandler handler, void *pCookie, XnCallbackHandle &amp;hCallback)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> xn::Context::RegisterToNodeCreation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxn_1_1_context.html#a138feec38f9d9c865b369a2093d4c9af">NodeCreationHandler</a>&nbsp;</td>
          <td class="paramname"> <em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pCookie</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_xn_types_8h.html#a5d00277c28def4d18f1605d5198ad77d">XnCallbackHandle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>hCallback</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Registers an event handler for the 'Node Creation' event. see <a class="el" href="classxn_1_1_context.html#context_node_creation_event">Event: 'Node Creation'</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>handler</em>&nbsp;</td><td>Callback function to be invoked when the event is raised. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pCookie</em>&nbsp;</td><td>User's cookie, to be delivered to the callback. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>hCallback</em>&nbsp;</td><td>Handle to the callback to be used for unregistering it.</td></tr>
  </table>
  </dd>
</dl>
<p>For full details and usage of the parameters, see <a class="el" href="conc__events.html#reg_to_events">Registering to Events</a>. </p>

</div>
</div>
<a class="anchor" id="accd23341f93552deca937733a6b82ab2"></a><!-- doxytag: member="xn::Context::RegisterToNodeDestruction" ref="accd23341f93552deca937733a6b82ab2" args="(NodeDestructionHandler handler, void *pCookie, XnCallbackHandle &amp;hCallback)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> xn::Context::RegisterToNodeDestruction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxn_1_1_context.html#a684270053551213f42897f192c441858">NodeDestructionHandler</a>&nbsp;</td>
          <td class="paramname"> <em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pCookie</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_xn_types_8h.html#a5d00277c28def4d18f1605d5198ad77d">XnCallbackHandle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>hCallback</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Registers an event handler for the 'Node Destruction' event. see <a class="el" href="classxn_1_1_context.html#context_node_destruction_event">Event: 'Node Destruction'</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>handler</em>&nbsp;</td><td>Callback function to be invoked when the event is raised. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pCookie</em>&nbsp;</td><td>User's cookie, to be delivered to the callback. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>hCallback</em>&nbsp;</td><td>Handle to the callback to be used for unregistering it.</td></tr>
  </table>
  </dd>
</dl>
<p>For full details and usage of the parameters, see <a class="el" href="conc__events.html#reg_to_events">Registering to Events</a>. </p>

</div>
</div>
<a class="anchor" id="a45b4f74d21dcca83a643e8566beb459d"></a><!-- doxytag: member="xn::Context::Release" ref="a45b4f74d21dcca83a643e8566beb459d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xn::Context::Release </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Releases a context object, decreasing its ref count by 1. If reference count has reached 0, the context will be destroyed.  For full details and usage, see <a class="el" href="group__context.html#ga312163c183d1fecd902927a76d914183">xnContextRelease</a> </p>

</div>
</div>
<a class="anchor" id="a3cdce851bb38afd2555549c2120861ba"></a><!-- doxytag: member="xn::Context::RunXmlScript" ref="a3cdce851bb38afd2555549c2120861ba" args="(const XnChar *strScript, ScriptNode &amp;scriptNode, EnumerationErrors *pErrors=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> xn::Context::RunXmlScript </td>
          <td>(</td>
          <td class="paramtype">const XnChar *&nbsp;</td>
          <td class="paramname"> <em>strScript</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxn_1_1_script_node.html">ScriptNode</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>scriptNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxn_1_1_enumeration_errors.html">EnumerationErrors</a> *&nbsp;</td>
          <td class="paramname"> <em>pErrors</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Runs an XML script string to build a production graph. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>strScript</em>&nbsp;</td><td>String containing an XML script. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>scriptNode</em>&nbsp;</td><td><a class="el" href="classxn_1_1_script_node.html">xn::ScriptNode</a> object as the root to all the nodes created from the XML file. When no longer needed, the node can be released, causing all the created nodes to decrement their reference counts. </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>pErrors</em>&nbsp;</td><td>Optional. To be filled with enumeration errors.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Remarks:</b></p>
<p>For a full description of the XML structure, see <a class="el" href="xmlscripts.html">Xml Scripts</a>. Compare this method with initialization methods that run an XML script from a file. </p>

</div>
</div>
<a class="anchor" id="a0145a926d2656d0f05399ed8d5f90ec6"></a><!-- doxytag: member="xn::Context::RunXmlScriptFromFile" ref="a0145a926d2656d0f05399ed8d5f90ec6" args="(const XnChar *strFileName, ScriptNode &amp;scriptNode, EnumerationErrors *pErrors=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> xn::Context::RunXmlScriptFromFile </td>
          <td>(</td>
          <td class="paramtype">const XnChar *&nbsp;</td>
          <td class="paramname"> <em>strFileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxn_1_1_script_node.html">ScriptNode</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>scriptNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxn_1_1_enumeration_errors.html">EnumerationErrors</a> *&nbsp;</td>
          <td class="paramname"> <em>pErrors</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Runs an XML script file to build a production graph. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>strFileName</em>&nbsp;</td><td>Name of file containing an XML script. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>scriptNode</em>&nbsp;</td><td>scriptNode object as the root to all the nodes created from the XML file. When no longer needed, the node can be released, causing all the created nodes to decrement their reference counts. </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>pErrors</em>&nbsp;</td><td>Optional. To be filled with enumeration errors.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Remarks:</b></p>
<p>The XML script file describes all the nodes you want to create. For each node description in the XML file, this method creates a <a class="el" href="classxn_1_1_production_node.html">xn::ProductionNode</a> object. </p>

</div>
</div>
<a class="anchor" id="adcdabaa87787c0e3b61e37619c6a6590"></a><!-- doxytag: member="xn::Context::SetGlobalMirror" ref="adcdabaa87787c0e3b61e37619c6a6590" args="(XnBool bMirror)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> xn::Context::SetGlobalMirror </td>
          <td>(</td>
          <td class="paramtype">XnBool&nbsp;</td>
          <td class="paramname"> <em>bMirror</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enables/disables the GlobalMirror flag. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bMirror</em>&nbsp;</td><td>New mirroring state.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Remarks:</b></p>
<p>See <a class="el" href="conc__global__mirror.html">Global Mirror</a> for understanding of the 'Global Mirror' concept. </p>

</div>
</div>
<a class="anchor" id="ae9b3626c96bda6f9423de567061b05ae"></a><!-- doxytag: member="xn::Context::SetHandle" ref="ae9b3626c96bda6f9423de567061b05ae" args="(XnContext *pContext)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xn::Context::SetHandle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_xn_types_8h.html#afe4a53c10750f7f95282a2b1568d3732">XnContext</a> *&nbsp;</td>
          <td class="paramname"> <em>pContext</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Replaces the underlying C object pointed to by this object. </p>

</div>
</div>
<a class="anchor" id="affa5173b7c32b98d344ab2c8634f2cb7"></a><!-- doxytag: member="xn::Context::StartGeneratingAll" ref="affa5173b7c32b98d344ab2c8634f2cb7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> xn::Context::StartGeneratingAll </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Ensures all created <a class="el" href="glossary.html#dict_gen_node">generator nodes</a> are generating data. </p>

</div>
</div>
<a class="anchor" id="aecf4d38b0cc4b50a376a83c4761670b5"></a><!-- doxytag: member="xn::Context::StopGeneratingAll" ref="aecf4d38b0cc4b50a376a83c4761670b5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> xn::Context::StopGeneratingAll </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Ensures all <a class="el" href="glossary.html#dict_gen_node">generator nodes</a> are not generating data. </p>

</div>
</div>
<a class="anchor" id="accbc2a151989fe58879aa1f0bef81e85"></a><!-- doxytag: member="xn::Context::TakeOwnership" ref="accbc2a151989fe58879aa1f0bef81e85" args="(XnContext *pContext)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xn::Context::TakeOwnership </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_xn_types_8h.html#afe4a53c10750f7f95282a2b1568d3732">XnContext</a> *&nbsp;</td>
          <td class="paramname"> <em>pContext</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a45df3c90dc12709c777ef1b531bab8b3"></a><!-- doxytag: member="xn::Context::UnregisterFromErrorStateChange" ref="a45df3c90dc12709c777ef1b531bab8b3" args="(XnCallbackHandle hCallback)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xn::Context::UnregisterFromErrorStateChange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_xn_types_8h.html#a5d00277c28def4d18f1605d5198ad77d">XnCallbackHandle</a>&nbsp;</td>
          <td class="paramname"> <em>hCallback</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unregisters an event handler for the 'Global Error State Change' event. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>hCallback</em>&nbsp;</td><td>Handle received from registration.</td></tr>
  </table>
  </dd>
</dl>
<p>For full details and usage of the parameter, see <a class="el" href="conc__events.html#unreg_from_events">Unregistering from Events</a> . </p>

</div>
</div>
<a class="anchor" id="a2714f66a8247705422a56621574671d0"></a><!-- doxytag: member="xn::Context::UnregisterFromNodeCreation" ref="a2714f66a8247705422a56621574671d0" args="(XnCallbackHandle hCallback)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xn::Context::UnregisterFromNodeCreation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_xn_types_8h.html#a5d00277c28def4d18f1605d5198ad77d">XnCallbackHandle</a>&nbsp;</td>
          <td class="paramname"> <em>hCallback</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unregisters an event handler for the 'Node Creation' event. see <a class="el" href="classxn_1_1_context.html#context_node_creation_event">Event: 'Node Creation'</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>hCallback</em>&nbsp;</td><td>Handle received from registration.</td></tr>
  </table>
  </dd>
</dl>
<p>For full details and usage of the parameter, see <a class="el" href="conc__events.html#unreg_from_events">Unregistering from Events</a>. </p>

</div>
</div>
<a class="anchor" id="aa85fb69ce08a373a9a6fdd25d697dd4f"></a><!-- doxytag: member="xn::Context::UnregisterFromNodeDestruction" ref="aa85fb69ce08a373a9a6fdd25d697dd4f" args="(XnCallbackHandle hCallback)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xn::Context::UnregisterFromNodeDestruction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_xn_types_8h.html#a5d00277c28def4d18f1605d5198ad77d">XnCallbackHandle</a>&nbsp;</td>
          <td class="paramname"> <em>hCallback</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unregisters an event handler for the 'Node Destruction' event. see <a class="el" href="classxn_1_1_context.html#context_node_destruction_event">Event: 'Node Destruction'</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>hCallback</em>&nbsp;</td><td>Handle received from registration.</td></tr>
  </table>
  </dd>
</dl>
<p>For full details and usage of the parameter, see <a class="el" href="conc__events.html#unreg_from_events">Unregistering from Events</a>. </p>

</div>
</div>
<a class="anchor" id="a52929d2a535166b18098e066900f9d59"></a><!-- doxytag: member="xn::Context::WaitAndUpdateAll" ref="a52929d2a535166b18098e066900f9d59" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> xn::Context::WaitAndUpdateAll </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Updates all generator nodes in the context to their latest available data, first waiting for all nodes to have new data available. </p>
<p><b>Remarks</b></p>
<p>This method requests from OpenNI to cause all nodes in the context's Production Graph that have new data available to update their application buffers with the new data, each node updating its own application buffer.</p>
<p>Before OpenNI causes the data updates, it waits until <b>all</b> the nodes have notified that they have new data available. On receiving all the 'new data available' notifications, OpenNI then causes all nodes with new data available to update their application buffers with their new data. At this stage the generator nodes have "generated" new data. This method then stops waiting and returns a success status. The application can now read the newly generated data.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Using this method is not recommended for most applications since it requires <em>all</em> the nodes to have new data. Consider instead using <a class="el" href="classxn_1_1_context.html#a17fab043d7b6d60728511527a1d5c090">WaitAnyUpdateAll()</a> or <a class="el" href="classxn_1_1_context.html#ad4bab84f35a855639d485da99a05c585">WaitOneUpdateAll()</a>. Typical applications use the <a class="el" href="classxn_1_1_context.html#a17fab043d7b6d60728511527a1d5c090" title="Updates all generator nodes in the context to their latest available data, first...">WaitAnyUpdateAll()</a> method.</dd></dl>
<p>An error situation is defined as: after a preset timeout, not all nodes have yet notified OpenNI they have new data available. On error, the method stops waiting and returns an error status. None of the nodes update their application buffers.</p>
<p>See <a class="el" href="conc__updating__data.html#conc_updating_data__summary_of_wait_fns">'Wait and Update' Methods</a> for an overview to the <a class="el" href="conc__updating__data.html">'WaitXUpdateAll'</a> methods and how to read the data from the nodes.</p>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>XN_STATUS_WAIT_DATA_TIMEOUT</em>&nbsp;</td><td>No new data available within 2 seconds. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a17fab043d7b6d60728511527a1d5c090"></a><!-- doxytag: member="xn::Context::WaitAnyUpdateAll" ref="a17fab043d7b6d60728511527a1d5c090" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> xn::Context::WaitAnyUpdateAll </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Updates all generator nodes in the context to their latest available data, first waiting for any of the nodes to have new data available. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Typical applications use this method. Consider using this method for your application.</dd></dl>
<p><b>Remarks</b></p>
<p>This method requests from OpenNI to cause all nodes with new data available in the context's Production Graph to update their application buffers with the new data, each node updating its own application buffer.</p>
<p>Before OpenNI causes the data updates, it waits for any of the nodes to have notified that it has new data available. On receiving a 'new data available' notification, OpenNI then causes all nodes with new data available to update their application buffers with their new data. At this stage the generator nodes have "generated" new data. This method then stops waiting and returns a success status. The application can now read the newly generated data.</p>
<p>A node that does not have new data available does not update its application buffer.</p>
<p>An error situation is defined as: after a preset timeout, none of the nodes have yet notified OpenNI they have new data available. On error, the method stops waiting and returns an error status. None of the nodes update their application buffers.</p>
<p>See <a class="el" href="conc__updating__data.html#conc_updating_data__summary_of_wait_fns">'Wait and Update' Methods</a> for an overview to the <a class="el" href="conc__updating__data.html">'WaitXUpdateAll'</a> methods and how to read the data from the nodes.</p>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>XN_STATUS_WAIT_DATA_TIMEOUT</em>&nbsp;</td><td>No new data available within 2 seconds. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae498b727aa0fdade75f91bdb2563f88c"></a><!-- doxytag: member="xn::Context::WaitNoneUpdateAll" ref="ae498b727aa0fdade75f91bdb2563f88c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> xn::Context::WaitNoneUpdateAll </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Immediately updates all generator nodes in the context to their latest available data, without waiting for notification that any node has new data available. </p>
<p><b>Remarks</b></p>
<p>This method requests from OpenNI to cause all nodes in the context's Production Graph with new data available to update their application buffers with the new data, each node updating its own application buffer.</p>
<p>OpenNI causes all nodes with new data available to update their application buffers with their new data. At this stage the generator nodes have "generated" new data. This method returns a success status. The application can now read the newly generated data.</p>
<p>A node that does not have new data available does not update its application buffer.</p>
<p>See <a class="el" href="conc__updating__data.html#conc_updating_data__summary_of_wait_fns">'Wait and Update' Methods</a> for an overview to the <a class="el" href="conc__updating__data.html">'WaitXUpdateAll'</a> methods and how to read the data from the nodes. </p>

</div>
</div>
<a class="anchor" id="ad4bab84f35a855639d485da99a05c585"></a><!-- doxytag: member="xn::Context::WaitOneUpdateAll" ref="ad4bab84f35a855639d485da99a05c585" args="(ProductionNode &amp;node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> xn::Context::WaitOneUpdateAll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxn_1_1_production_node.html">ProductionNode</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>node</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Updates all generator nodes in the context to their latest available data, first waiting for a specified node to have new data available. </p>
<p><b>Remarks</b></p>
<p>This method requests from OpenNI to cause all nodes in the context's Production Graph with new data available to update their application buffers with the new data, each node updating its own application buffer.</p>
<p>Before OpenNI causes the data updates, it waits for a specified node to notify that it has new data available. On receiving the 'new data available' notification, OpenNI then causes all nodes with new data available to update their application buffers with their new data. At this stage the generator nodes have "generated" new data. This method then stops waiting and returns a success status. The application can now read the newly generated data.</p>
<p>A node that does not have new data available does not update its application buffer.</p>
<p>An error situation is defined as: after a preset timeout, none of the nodes have yet notified OpenNI they have has new data available. On error, the method stops waiting and returns an error status. None of the nodes update their application buffers.</p>
<p>See <a class="el" href="conc__updating__data.html#conc_updating_data__summary_of_wait_fns">'Wait and Update' Methods</a> for an overview to the <a class="el" href="conc__updating__data.html">'WaitXUpdateAll'</a> methods and how to read the data from the nodes.</p>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>XN_STATUS_WAIT_DATA_TIMEOUT</em>&nbsp;</td><td>No new data available within 2 seconds. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_xn_cpp_wrapper_8h_source.html">XnCppWrapper.h</a></li>
</ul>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Wed Jun 13 21:55:51 2012 for OpenNI 1.5.4 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
