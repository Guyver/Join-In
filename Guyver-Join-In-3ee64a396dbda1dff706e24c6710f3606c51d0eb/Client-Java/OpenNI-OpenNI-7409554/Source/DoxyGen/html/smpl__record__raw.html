<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>OpenNI 1.5.4: NiRecordRaw.cpp - sample program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="main.html">OpenNI Overview</a>&nbsp;&raquo;&nbsp;<a class="el" href="smpls__n__guides.html">Samples and Guides</a>&nbsp;&raquo;&nbsp;<a class="el" href="smpls.html">Sample Programs for the OpenNI API</a>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="smpl_record_raw">NiRecordRaw.cpp - sample program </a></h1><p><b>Source file:</b> Click the following link to view the source code file:</p>
<ul>
<li>NiRecordRaw.cpp</li>
</ul>
<p>This section describes an OpenNI sample program for recording raw data, and then playing it back. Recording raw data may be useful for middleware developers who produce a custom type of data that isn't defined by OpenNI. In addition, recording raw data may also be useful for middleware developers who save additional debugging information in the ONI file. This additional data may be used in conjunction with the standard OpenNI data types such as depth output data stored in the file. In this case, each frame of debugging information will match a depth frame.</p>
<p>In this sample, the raw data is artificial data that the application itself synthesizes.</p>
<h2><a class="anchor" id="recraw__sample_xml_path">
Declaration of File Paths</a></h2>
<p>In the following definitions, SAMPLE_XML_PATH is for the path to an OpenNI XML script input file for building a stored production graph. The <em>production graph</em> is a network of <em>production nodes</em> and is the principal OpenNI object model. See <a class="el" href="prod__graph.html">The Production Graph</a> for more about production graph. RECORDING_FILE_NAME is the OpenNI output file to store the recording. </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">            #define SAMPLE_XML_PATH &quot;../../../../Data/SamplesConfig.xml&quot;</span>
<span class="preprocessor">            #define RECORDING_FILE_NAME &quot;recordingWithRaw.oni&quot;</span>
</pre></div><h2><a class="anchor" id="bkrec_macros">
Macro Declarations</a></h2>
<p>At the top of the program are two macro utility declarations, both of which call OpenNI methods. They are described below. However, for the sake of conciseness, the rest of this documentation skips calls to these macros.</p>
<p>The CHECK_RC_ERR() macro checks whether the most recent OpenNI operation for creating a production graph actually created a production graph or not. If no production graph was created (indicated by the <code>XN_STATUS_NO_NODE_PRESENT</code> return code), the <a class="el" href="_xn_status_8h.html#a709a2190465f4a6d7893587e53d66798">xnGetStatusString()</a> method converts an error list to a error string for printing. Either way, this macro then calls the <code>CHECK_RC()</code> macro described above. </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">            #define CHECK_RC_ERR(rc, what, error) \</span>
<span class="preprocessor">              ...           </span>
</pre></div><h2><a class="anchor" id="recraw_mainprg_dcl_blk">
Main Program - Declaration Block</a></h2>
<p>The declaration block at the top of the main program declares an OpenNI status flag for collecting return values from method calls. </p>
<div class="fragment"><pre class="fragment">            <a class="code" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> nRetVal = <a class="code" href="_xn_status_8h.html#a92729089d8e28e740a3f8b5169c8f695">XN_STATUS_OK</a>;
</pre></div><h2><a class="anchor" id="recraw_mainprg">
Main Program</a></h2>
<h3><a class="anchor" id="recraw_record">
Recording Data</a></h3>
<p>In the following, the <a class="el" href="_xn_log_8h.html#a98c98054c03755c961d383e12b36b7dc">xn::xnLogInitFromXmlFile()</a> function initializes the log from an XML file. </p>
<div class="fragment"><pre class="fragment">                nRetVal = <a class="code" href="_xn_log_8h.html#a98c98054c03755c961d383e12b36b7dc">xnLogInitFromXmlFile</a>(SAMPLE_XML_PATH);
</pre></div><p>The following initalizes the <a class="el" href="classxn_1_1_context.html">xn::Context</a> object. This is a workspace where the application builds an OpenNI production graph. The <em>production graph</em> is a network of <em>production nodes</em> and is the principal OpenNI object structure. </p>
<div class="fragment"><pre class="fragment">                Context context;
                nRetVal = context.Init();
</pre></div><p>The following statement initializes a Recorder object. This object records to a specified destination medium the frames of data from each node that was added to the Recorder node. </p>
<div class="fragment"><pre class="fragment">                nRetVal = recorder.Create(context);
</pre></div><p>The following call specifies to where the recorder must send its recording.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Disk files are the only medium that this installation currently supports.</dd></dl>
<div class="fragment"><pre class="fragment">                nRetVal = recorder.SetDestination(<a class="code" href="group__recorder.html#gga3a9ee4c35a7384ba06a4d22f976f8e8aab2fd201e9160a675b83ca2a3e4d36a0c">XN_RECORD_MEDIUM_FILE</a>, RECORDING_FILE_NAME);
</pre></div><p>The following code creates a mock node. This is to simulate an actual node when recording or playing data from a recording. A mock node does not contain any logic for generating data. Instead, it allows an outside component &ndash; such as an application or a real node &ndash; to feed it configuration changes and data. </p>
<div class="fragment"><pre class="fragment">                MockRawGenerator rawGenerator;
                nRetVal = rawGenerator.Create(context, <span class="stringliteral">&quot;MockRaw&quot;</span>);
</pre></div><p>The following statements set properties of the <a class="el" href="classxn_1_1_mock_raw_generator.html">rawGenerator</a> node. It creates a string property named Type and assigns it the value "ReverseT", creates an integer property named X and assigns it the value 5. This depends on the middleware developer that is using this feature. It could be any parameter that the middleware code might later need for debugging purposes or for custom data types. </p>
<div class="fragment"><pre class="fragment">                nRetVal = rawGenerator.SetStringProperty(<span class="stringliteral">&quot;Type&quot;</span>, <span class="stringliteral">&quot;ReverseT&quot;</span>);
                nRetVal = rawGenerator.SetIntProperty(<span class="stringliteral">&quot;X&quot;</span>, 5);
</pre></div><p>The following statement adds the node to the recording setup, and starts recording it. </p>
<div class="fragment"><pre class="fragment">                nRetVal = recorder.AddNodeToRecording(rawGenerator);
</pre></div><p>The following example shows that properties can also be set after the node has been added to the recording. </p>
<div class="fragment"><pre class="fragment">                nRetVal = rawGenerator.SetIntProperty(<span class="stringliteral">&quot;Y&quot;</span>, 8);
</pre></div><p>The following main application loop sets artificial data in the rawGenerator node. The parameters to the SetData() call, in order, are nFrameID and nTimestamp, both generated from the loop counter - abd then the nDataSize and a pointer to the data buffer. </p>
<div class="fragment"><pre class="fragment">                XnChar buff[20];
                <span class="keywordflow">for</span> (XnUInt32 i = 1; i &lt;= 10; i++)
                {
                    <span class="keywordflow">for</span> (XnUInt32 j = 0; j &lt; 20; j++)
                    {
                        buff[j] = i;
                    }
                    nRetVal = rawGenerator.SetData(1000 * i, i, <span class="keyword">sizeof</span>(buff), buff);nRetVal = recorder.Record();
</pre></div><p>In the above, the <a class="el" href="classxn_1_1_recorder.html#a94a2c702fd2c5e2466b813bb585e6fc9">Record()</a> method records one frame of data from each node added to the recorder. To record continually, the recorder node must be called repeatedly for each frame.</p>
<p>On completion of the loop, the following code removes the node from the Recorder object and so stops recording the node output. The code then releases the <a class="el" href="classxn_1_1_recorder.html">Recorder</a> and <a class="el" href="classxn_1_1_mock_raw_generator.html">MockRawGenerator</a> nodes. Releasing the nodes unreferences them, decreasing their reference counts by 1. If a node's reference count reaches zero, it will be destroyed. </p>
<div class="fragment"><pre class="fragment">                nRetVal = recorder.RemoveNodeFromRecording(rawGenerator);
                   ...
                recorder.Release();
                   ...
                rawGenerator.Release();
</pre></div><p>This completes the recording example. All recorded data has been recorded in the file whose name is given in RECORDING_FILE_NAME.</p>
<h3><a class="anchor" id="recraw_play">
Plays Back Recorded Data</a></h3>
<p>The application now builds a production graph to play back the data recorded above</p>
<p>The following statement gets a handle to an existing production node instance using that instance name. It is already known that there exists a node with the instance name "MockRaw". </p>
<div class="fragment"><pre class="fragment">                nRetVal = context.GetProductionNodeByName(<span class="stringliteral">&quot;MockRaw&quot;</span>, rawGenerator);
</pre></div><p>The following code replays a recorded file of a session of OpenNI data generation exactly as it was recorded. the <a class="el" href="classxn_1_1_player.html">xn::Player</a> node is for playing a saved recording of an OpenNI data generation session. The RECORDING_FILE_NAME string contains the file name, as above. </p>
<div class="fragment"><pre class="fragment">                Player player;
                nRetVal = context.OpenFileRecording(RECORDING_FILE_NAME, player);
</pre></div><p>The following statement specifies whether the player will automatically rewind to the beginning of the recording after reaching the end of the recording. </p>
<div class="fragment"><pre class="fragment">                nRetVal = player.SetRepeat(<a class="code" href="_xn_platform_8h.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>);
</pre></div><div class="fragment"><pre class="fragment">                nRetVal = context.GetProductionNodeByName(<span class="stringliteral">&quot;MockRaw&quot;</span>, rawGenerator);
</pre></div><p>The following program loop waits for available data from any generator node and prints it out. The <a class="el" href="classxn_1_1_context.html#a17fab043d7b6d60728511527a1d5c090">WaitAnyUpdateAll()</a> method updates all generator nodes in the context that have new data available, first waiting for any of the nodes to have new data available. The application can then get the data (for example, using a metadata <code>GetData()</code> method). This method has a timeout. </p>
<div class="fragment"><pre class="fragment">                <span class="keywordflow">while</span> ((nRetVal = context.WaitAnyUpdateAll()) != XN_STATUS_EOF)
                {
                    CHECK_RC(nRetVal, <span class="stringliteral">&quot;Read data from file&quot;</span>);
                    pData = (<span class="keyword">const</span> XnChar*)rawGenerator.GetData();
                    nSize = rawGenerator.GetDataSize();
                    <span class="keywordflow">for</span> (XnUInt32 i = 0; i &lt; nSize; i++)
                    {
                        printf(<span class="stringliteral">&quot;%d &quot;</span>, pData[i]);
                    }
                    printf(<span class="stringliteral">&quot;\n&quot;</span>);
                }
</pre></div><p>On completion of the loop, the following code removes the node from the Player object and and so stops playing the recording. All other objects are also released. See ealier for a more detailed description of Release(). </p>
<div class="fragment"><pre class="fragment">                player.Release();
                rawGenerator.Release();
                recorder.Release();
                context.Release();
</pre></div> </div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Wed Jun 13 21:55:36 2012 for OpenNI 1.5.4 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
